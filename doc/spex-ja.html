<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

<head>
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="Mikio Hirabayashi" />
<meta name="keywords" content="Tokyo Cabinet, tokyocabinet, database, DBM" />
<meta name="description" content="Specifications of Tokyo Cabinet" />
<link rel="contents" href="./" />
<link rel="alternate" href="spex-en.html" hreflang="en" title="the English version" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:mikio@users.sourceforge.net" />
<title>Fundamental Specifications of Tokyo Cabinet Version 1 (Japanese)</title>
</head>

<body>

<h1>Tokyo Cabinet第1版基本仕様書</h1>

<div class="note">Copyright (C) 2006-2008 Mikio Hirabayashi</div>
<div class="note">Last Update: Thu, 17 Jan 2008 01:09:19 +0900</div>
<div class="navi">[<a href="spex-en.html" hreflang="en">English</a>/<span class="void">Japanese</span>] [<a href="index.ja.html">HOME</a>]</div>

<hr />

<h2 id="contents">目次</h2>

<ol>
<li><a href="#introduction">はじめに</a></li>
<li><a href="#features">特徴</a></li>
<li><a href="#installation">インストール</a></li>
<li><a href="#tcutilapi">ユーティリティAPI</a></li>
<li><a href="#tchdbapi">ハッシュデータベースAPI</a></li>
<li><a href="#tcbdbapi">B+木データベースAPI</a></li>
<li><a href="#tcadbapi">抽象データベースAPI</a></li>
<li><a href="#tips">ちょっとしたコツ</a></li>
<li><a href="#fileformat">ファイルフォーマット</a></li>
<li><a href="#faq">よく聞かれる質問</a></li>
<li><a href="#license">ライセンス</a></li>
</ol>

<hr />

<h2 id="introduction">はじめに</h2>

<p>Tokyo Cabinetはデータベースを扱うルーチン群のライブラリです。データベースといっても単純なもので、キーと値のペアからなるレコード群を格納したデータファイルです。キーと値は任意の長さを持つ一連のバイト列であり、文字列でもバイナリでも扱うことができます。テーブルやデータ型の概念はありません。レコードはハッシュ表またはB+木で編成されます。</p>

<p>ハッシュ表のデータベースでは、キーはデータベース内で一意であり、キーが重複する複数のレコードを格納することはできません。このデータベースに対しては、キーと値を指定してレコードを格納したり、キーを指定して対応するレコードを削除したり、キーを指定して対応するレコードを検索したりすることができます。また、データベースに格納してある全てのキーを順不同に一つずつ取り出すこともできます。このような操作は、UNIX標準で定義されているDBMライブラリおよびその追従であるNDBMやGDBMに類するものです。Tokyo CabinetはDBMのより良い代替として利用することができます。</p>

<p>B+木のデータベースでは、キーが重複する複数のレコードを格納することができます。このデータベースに対しては、ハッシュ表のデータベースと同様に、キーを指定してレコードを格納したり取り出したり削除したりすることができます。レコードはユーザが指示した比較関数に基づいて整列されて格納されます。カーソルを用いて各レコードを昇順または降順で参照することができます。この機構によって、文字列の前方一致検索や数値の範囲検索が可能になります。また、B+木のデータベースではトランザクションが利用できます。</p>

<p>Tokyo CabinetはC言語で記述され、CとPerlとRubyとJavaのAPIとして提供されます。Tokyo CabinetはC99およびPOSIX準拠のAPIを備えるプラットフォームで利用できます。Tokyo CabinetはGNU Lesser General Public Licenseに基づくフリーソフトウェアです。</p>

<hr />

<h2 id="features">特徴</h2>

<p>Tokyo CabinetはQDBMの後継であり、空間効率と時間効率と使いやすさを向上させた製品です。この節ではTokyo Cabinetの特徴について説明します。</p>

<h3>DBM一族の最右翼</h3>

<p>Tokyo CabinetはQDBMの後継として次の点を目標として開発されました。これらの目標は達成されており、Tokyo CabinetはQDBMを置き換える製品だと言えます。</p>

<ul>
<li>時間効率の向上 : データベースファイルがより小さい</li>
<li>空間効率の向上 : 処理がより高速である</li>
<li>並列性の向上 : マルチスレッド環境での同時実行性能の向上</li>
<li>利便性の向上 : APIがより単純である</li>
<li>堅牢性の向上 : 不慮の事態でもデータベースファイルが壊れにくい</li>
<li>64ビット対応 : 巨大なメモリ空間とデータベースファイルを扱える</li>
</ul>

<p>Tokyo CabinetはQDBMと同様に、伝統的なDBMが抱える三つの制限事項を回避しています。すなわち、プロセス内で複数のデータベースを扱うことができ、キーと値のサイズに制限がなく、データベースファイルがスパースではありません。さらに、QDBMが抱える三つの制限事項を回避しています。すなわち、2GB以上のデータベースファイルを扱うことができ、バイトオーダの異なる環境間でデータベースファイルを共有することができ、複数のスレッドが同時にデータベースの探索を行うことができます。</p>

<p>Tokyo Cabinetは高速に動作します。例えば100万件のレコードの登録にかかる時間は、ハッシュデータベースで1.5秒ほど、B+木データベースで2.2秒ほどです。そしてTokyo Cabinetのデータベースは小さいです。例えば1レコードあたりのオーバーヘッドは、ハッシュデータベースで16バイトほど、B+木データベースで5バイトほどです。さらにTokyo Cabinetで扱えるデータの規模は莫大です。最大8EB（9.22e18バイト）までのデータベースファイルを扱うことができます。</p>

<h3>効率的なハッシュデータベースの実装</h3>

<p>Tokyo Cabinetはレコードの探索にハッシュアルゴリズムを用います。バケット配列に十分な要素数があれば、レコードの探索にかかる時間計算量は O(1) です。すなわち、レコードの探索に必要な時間はデータベースの規模に関わらず一定です。追加や削除に関しても同様です。ハッシュ値の衝突はセパレートチェーン法で管理します。チェーンのデータ構造は二分探索木です。したがって、バケット配列の要素数が著しく少ない場合でも、探索等の時間計算量は O(log n) に抑えられます。</p>

<p>Tokyo Cabinetはバケット配列を全てRAM上に保持することによって、処理の高速化を図ります。バケット配列がRAM上にあれば、ほぼ1パスのファイル操作でレコードに該当するファイル上の領域を参照することができます。ファイルに記録されたバケット配列は `read' コールでRAM上に読み込むのではなく、`mmap' コールでRAMに直接マッピングされます。したがって、データベースに接続する際の準備時間が極めて短く、また、複数のプロセスでメモリマップを共有することができます。</p>

<p>バケット配列の要素数が格納するレコード数の半分ほどであれば、データの性質によって多少前後しますが、ハッシュ値の衝突率は56.7%ほどです（等倍だと36.8%、2倍だと21.3%、4倍だと11.5%、8倍だと6.0%ほど）。そのような場合、平均2パス以下のファイル操作でレコードを探索することができます。これを性能指標とするならば、例えば100万個のレコードを格納するためには50万要素のバケット配列が求められます。バケット配列の各要素は4バイトです。すなわち、2MバイトのRAMが利用できれば100万レコードのデータベースが構築できます。</p>

<p>伝統的なDBMにはレコードの追加操作に関して「挿入」モードと「置換」モードがあります。前者では、キーが既存のレコードと重複する際に既存の値を残します。後者では、キーが既存のレコードと重複した際に新しい値に置き換えます。Tokyo Cabinetはその２つに加えて「連結」モードがあります。既存の値の末尾に指定された値を連結して格納する操作です。レコードの値を配列として扱う場合、要素を追加するには連結モードが役に立ちます。また、DBMではレコードの値を取り出す際にはその全ての領域を処理対象にするしか方法がありませんが、Tokyo Cabinetでは値の領域の一部のみを選択して取り出すことができます。レコードの値を配列として扱う場合にはこの機能も役に立ちます。</p>

<p>一般的に、データベースの更新処理を続けるとファイル内の利用可能領域の断片化が起き、ファイルのサイズが肥大化してしまいます。Tokyo Cabinetは隣接する不要領域を連結して再利用し、またデータベースの最適化機能を備えることによってこの問題に対処します。既存のレコードの値をより大きなサイズの値に上書きする場合、そのレコードの領域をファイル中の別の位置に移動させる必要があります。この処理の時間計算量はレコードのサイズに依存するので、値を拡張していく場合には効率が悪くなります。しかし、Tokyo Cabinetはアラインメントによってこの問題に対処します。増分がパディングに収まれば領域を移動させる必要はありません。</p>

<h3>便利なB+木データベースの実装</h3>

<p>B+木データベースはハッシュデータベースより遅いのですが、ユーザが定義した順序に基づいて各レコードを参照できることが特長です。B+木は複数のレコードを整列させた状態で論理的なページにまとめて管理します。各ページに対してはB木すなわち多進平衡木によって階層化された疎インデックスが維持されます。したがって、各レコードの探索等にかかる時間計算量は O(log n) です。各レコードを順番に参照するためにカーソルが提供されます。カーソルの場所はキーを指定して飛ばすことができ、また現在の場所から次のレコードに進めたり前のレコードに戻したりすることができます。各ページは双方向リンクリストで編成されるので、カーソルを前後に移動させる操作の時間計算量は O(1) です。</p>

<p>B+木データベースは上述のハッシュデータベースを基盤として実装されます。B+木の各ページはハッシュデータベースのレコードとして記録されるので、ハッシュデータベースの記憶管理の効率性を継承しています。B+木では各レコードのヘッダが小さく、アラインメントはページの単位でとられるので、ほとんどの場合、ハッシュデータベースに較べてデータベースファイルのサイズが半減します。B+木を更新する際には多くのページを操作する必要がありますが、Tokyo Cabinetはページをキャッシュすることによってファイル操作を減らして処理を効率化します。ほとんどの場合、疎インデックス全体がメモリ上にキャッシュされるので、各レコードを参照するのに必要なファイル操作は平均1パス以下です。</p>

<p>B+木データベースはトランザクション機構を提供します。トランザクションを開始してから終了するまでの一連の操作を一括してデータベースにコミットしたり、一連の更新操作を破棄してデータベースの状態をトランザクションの開始前の状態にロールバックしたりすることができます。トランザクションの分離レベルは2種類あります。データベースに対する全ての操作をトランザクション内で行うと直列化可能（serializable）トランザクションとなり、トランザクション外の操作を同時に行うと非コミット読み取り（read uncommitted）トランザクションとなります。</p>

<p>各ページを圧縮して保存する機能も提供されます。圧縮方式はZLIBのDeflateとブロックソーティングの2種類をサポートしています。同一ページ内の各レコードは似たようなパターンを持つため、Lempel-ZivやBWTなどのアルゴリズムを適用すると高い圧縮効率が期待できます。テキストデータを扱う場合、データベースのサイズが元の25%程度になります。データベースの規模が大きくディスクI/Oがボトルネックとなる場合は、圧縮機能を有効化すると処理速度が大幅に改善されます。</p>

<h3>単純だが多様なインタフェース群</h3>

<p>Tokyo Cabinetはオブジェクト指向に基づいた簡潔なAPIを提供します。データベースに対する全ての操作はデータベースオブジェクトにカプセル化され、開く（open）、閉じる（close）、挿入する（put）、削除する（out）、取得する（get）といった関数（メソッド）を呼ぶことでプログラミングを進めていけます。ハッシュデータベースとB+木データベースのAPIは互いに酷似しているので、アプリケーションを一方から他方に移植することも簡単です。</p>

<p>Tokyo Cabinetにはデータベースに接続するモードとして、「リーダ」と「ライタ」の二種類があります。リーダは読み込み専用で、ライタは読み書き両用です。データベースにはファイルロックによってプロセス間での排他制御が行われます。ライタが接続している間は、他のプロセスはリーダとしてもライタとしても接続できません。リーダが接続している間は、他のプロセスのリーダは接続できるが、ライタは接続できません。この機構によって、マルチタスク環境での同時接続に伴うデータの整合性が保証されます。</p>

<p>Tokyo CabinetのAPIの各関数はリエントラントであり、マルチスレッド環境で安全に利用することができます。別個のデータベースオブジェクトに対しては全ての操作を完全に並列に行うことができます。同一のデータベースオブジェクトに対しては、リードライトロックで排他制御を行います。すなわち、読み込みを行うスレッド同士は並列に実行でき、書き込みを行うスレッドは他の読み込みや書き込みをブロックします。</p>

<p>メモリ上でレコードを簡単に扱うために、ユーティリティAPIが提供されます。リストやマップといった基本的なデータ構造をはじめ、メモリプールや文字列処理や符号処理など、プログラミングで良く使う機能を詰め込んでいます。</p>

<p>C言語のAPIには、ユーティリティAPI、ハッシュデータベースAPI、B+木データベースAPI、抽象データベースAPIの四種類があります。各APIに対応したコマンドラインインタフェースも用意されています。それらはプロトタイピングやテストやデバッグなどで活躍するでしょう。Tokyo CabinetはC言語の他にも、Java、PerlおよびRubyのAPIを提供します。Java用APIはJava Native Interfaceを用いてハッシュデータベースAPIとB+木データベースAPIを呼び出すものです。Perl用APIはXS言語を用いてハッシュデータベースAPIとB+木データベースAPIを呼び出すものです。Ruby用APIはRubyのモジュールとしてハッシュデータベースAPIとB+木データベースAPIを呼び出すものです。その他の言語のインターフェイスも第三者によって提供されるでしょう。</p>

<p>複数のプロセスが同時にデータベースを操作したい場合やリモートホストにあるデータベースを操作したい場合には、リモートサービスを使うと便利です。リモートサービスはデータベースサーバとそのアクセスライブラリからなり、アプリケーションはリモートデータベースAPIを介してデータベースサーバを操作することができます。HTTPやmemcachedプロトコルもサポートするので、ほぼ全てのプラットフォームからデータベースサーバを簡単に操作することができます。</p>

<hr />

<h2 id="installation">インストール</h2>

<p>Tokyo Cabinetのソースパッケージからのインストール方法を説明します。バイナリパッケージのインストール方法についてはそれぞれのパッケージの説明書をご覧ください。</p>

<h3>前提</h3>

<p>Tokyo Cabinetの現在バージョンは、UNIX系のOSで利用することができます。少なくとも、以下の環境では動作するはずです。</p>

<ul>
<li>Linux 2.4以降 (x86-32/x86-64/PowerPC/Alpha/SPARC)</li>
<li>Mac OS X 10.3以降 (x86-32/x86-64/PowerPC)</li>
</ul>

<p>ソースパッケージを用いてTokyo Cabinetをインストールするには、<code>gcc</code>のバージョン3.1以降と<code>make</code>が必要です。それらはLinuxやFreeBSDなどには標準的にインストールされています。</p>

<p>Tokyo Cabinetは、以下のライブラリを利用しています。予めインストールしておいてください。</p>

<ul>
<li><a href="http://www.gzip.org/zlib/">zlib</a> : 可逆データ圧縮。バージョン1.2.1以降。</li>
</ul>

<h3>ビルドとインストール</h3>

<p>Tokyo Cabinetの配布用アーカイブファイルを展開したら、作成されたディレクトリに入ってインストール作業を行います。</p>

<p><code>configure</code>スクリプトを実行して、ビルド環境を設定します。</p>

<pre>./configure
</pre>

<p>プログラムをビルドします。</p>

<pre>make
</pre>

<p>プログラムの自己診断テストを行います。</p>

<pre>make check
</pre>

<p>プログラムをインストールします。作業は<code>root</code>ユーザで行います。</p>

<pre>make install
</pre>

<h3>結果</h3>

<p>一連の作業が終ると、以下のファイルがインストールされます。</p>

<pre>/usr/local/include/tcutil.h
/usr/local/include/tchdb.h
/usr/local/include/tcbdb.h
/usr/local/include/tcadb.h
/usr/local/lib/libtokyocabinet.a
/usr/local/lib/libtokyocabinet.so.2.1.0
/usr/local/lib/libtokyocabinet.so.2
/usr/local/lib/libtokyocabinet.so
/usr/local/lib/pkgconfig/tokyocabinet.pc
/usr/local/bin/tcucodec
/usr/local/bin/tcutest
/usr/local/bin/tcumttest
/usr/local/bin/tchmgr
/usr/local/bin/tchtest
/usr/local/bin/tchmttest
/usr/local/bin/tcbmgr
/usr/local/bin/tcbtest
/usr/local/bin/tcbmttest
/usr/local/bin/tcatest
/usr/local/share/tokyocabinet/...
/usr/local/man/man1/...
/usr/local/man/man3/...
</pre>

<h3>configureのオプション</h3>

<p>「<code>./configure</code>」を実行する際には、以下のオプションを指定することができます。</p>

<ul class="options">
<li><code>--enable-debug</code> : デバッグ用にビルドする。デバッグシンボルを有効化し、最適化を行わず、静的にリンクする。</li>
<li><code>--enable-devel</code> : 開発用にビルドする。デバッグシンボルを有効化し、最適化を行い、動的にリンクする。</li>
<li><code>--enable-profile</code> : プロファイル用にビルドする。プロファイルオプションを有効化し、最適化を行い、動的にリンクする。</li>
<li><code>--enable-fastest</code> : 最高速になるように最適化を行う。</li>
<li><code>--enable-off64</code> : 32ビット環境でも64ビットのファイルオフセットを用いる。</li>
<li><code>--enable-swab</code> : バイトオーダの変換を強制する。</li>
<li><code>--enable-uyield</code> : レースコンディションの検出用にビルドする。</li>
<li><code>--disable-zlib</code> : ZLIBによるレコード圧縮を無効にする。</li>
<li><code>--disable-pthread</code> : POSIXスレッドのサポートを無効にする。</li>
<li><code>--disable-shared</code> : 共有ライブラリのビルドを行わない。</li>
</ul>

<p>`<code>--prefix</code>' などのオプションも一般的なUNIXソフトウェアのパッケージと同様に利用可能です。`<code>/usr/local</code>' 以下ではなく '<code>/usr</code>' 以下にインストールしたい場合は `<code>--prefix=/usr</code>' を指定してください。なお、ライブラリ検索パスに `<code>/usr/local/lib</code>' が入っていない環境では、Tokyo Cabinetのアプリケーションを実行する際に環境変数 `<code>LD_LIBRARY_PATH</code>' の値に `<code>/usr/local/lib</code>' を含めておくようにしてください。</p>

<h3>ライブラリの使い方</h3>

<p>Tokyo CabinetはC言語のAPIを提供し、それはC89標準（ANSI C）またはC99標準に準拠したプログラムから利用することができます。Tokyo Cabinetヘッダは `<code>tcutil.h</code>'、`<code>tchdb.h</code>'、`<code>tcbdb.h</code>'、`<code>tcadb.h</code>' として提供されますので、適宜それらをアプリケーションのソースコード中でインクルードした上で、APIの各種機能を利用してください。ライブラリは `<code>libtokyocabinet.a</code>' および `<code>libtokyocabinet.so</code>' として提供され、それらは `<code>libz.so</code>'、`<code>libpthread.so</code>'、`<code>libm.so</code>'、`<code>libc.so</code>' に依存しますので、アプリケーションプログラムをビルドする際のリンカオプションには `<code>-ltokyocabinet</code>'、`<code>-lz</code>'、`<code>-lpthread</code>'、`<code>-lm</code>'、`<code>-lc</code>' を加えてください。最も典型的なビルド手順は以下のようになります。</p>

<pre>gcc -I/usr/local/include tc_example.c -o tc_example \
  -L/usr/local/lib -ltokyocabinet -lz -lpthread -lm -lc
</pre>

<p>Tokyo CabinetはC++言語のプログラムからも利用することができます。各ヘッダは暗黙的にCリンケージ（「<code>extern "C"</code>」ブロック）で包まれているので、単にインクルードするだけで利用することができます。</p>

<hr />

<h2 id="tcutilapi">ユーティリティAPI</h2>

<p>ユーティリティAPIは、メモリ上で簡単にレコードを扱うためのルーチン集です。特に拡張可能文字列と配列リストがハッシュマップが便利です。`<code>tcutil.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3>概要</h3>

<p>ユーティリティAPIを使うためには、`<code>tcutil.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>拡張可能文字列を扱う際には、`<code>TCXSTR</code>' 型へのポインタをオブジェクトとして用います。拡張可能文字列オブジェクトは、関数 `<code>tcxstrnew</code>' で作成し、関数 `<code>tcxstrdel</code>' で破棄します。配列リストを扱う際には、`<code>TCLIST</code>' 型へのポインタをオブジェクトとして用います。リストオブジェクトは、関数 `<code>tclistnew</code>' で作成し、関数 `<code>tclistdel</code>' で破棄します。ハッシュマップを扱う際には、`<code>TCMAP</code>' 型へのポインタをオブジェクトとして用います。マップオブジェクトは、関数 `<code>tcmapopen</code>' で作成し、関数 `<code>tcmapdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<h3>基礎的なユーティリティのAPI（英語御免）</h3>

<p>The constant `tcversion' is the string containing the version information.</p>

<dl class="api">
<dt><code>extern const char *tcversion;</code></dt>
</dl>

<p>The variable `tcfatalfunc' is the pointer to the call back function for handling a fatal error.</p>

<dl class="api">
<dt><code>extern void (*tcfatalfunc)(const char *);</code></dt>
<dd>The argument specifies the error message.</dd>
<dd>The initial value of this variable is `NULL'.  If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.</dd>
</dl>

<p>The function `tcmalloc' is used in order to allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmalloc(size_t <var>size</var>);</code></dt>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tccalloc' is used in order to allocate a nullified region on memory.</p>

<dl class="api">
<dt><code>void *tccalloc(size_t <var>nmemb</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>nmemb</var>' specifies the number of elements.</dd>
<dd>`<var>size</var>' specifies the size of each element.</dd>
<dd>The return value is the pointer to the allocated nullified region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `calloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcrealloc' is used in order to re-allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcrealloc(void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the re-allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `realloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmemdup' is used in order to duplicate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmemdup(const void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region of the duplicate.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcstrdup' is used in order to duplicate a string on memory.</p>

<dl class="api">
<dt><code>char *tcstrdup(const void *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the allocated string equivalent to the specified string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfree' is used in order to free a region on memory.</p>

<dl class="api">
<dt><code>void tcfree(void *<var>ptr</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.  If it is `NULL', this function has no effect.</dd>
<dd>Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.</dd>
</dl>

<h3>拡張可能文字列のAPI（英語御免）</h3>

<p>The function `tcxstrnew' is used in order to create an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew(void);</code></dt>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrnew2' is used in order to create an extensible string object from a character string.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew2(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of the initial content.</dd>
<dd>The return value is the new extensible string object containing the specified string.</dd>
</dl>

<p>The function `tcxstrnew3' is used in order to create an extensible string object with the initial allocation size.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew3(int <var>asiz</var>);</code></dt>
<dd>`<var>asiz</var>' specifies the initial allocation size.</dd>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrdup' is used in order to copy an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrdup(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the new extensible string object equivalent to the specified object.</dd>
</dl>

<p>The function `tcxstrdel' is used in order to delete an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrdel(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcxstrcat' is used in order to concatenate a region to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat(TCXSTR *<var>xstr</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region to be appended.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tcxstrcat2' is used in order to concatenate a character string to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat2(TCXSTR *<var>xstr</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>str</var>' specifies the string to be appended.</dd>
</dl>

<p>The function `tcxstrptr' is used in order to get the pointer of the region of an extensible string object.</p>

<dl class="api">
<dt><code>const void *tcxstrptr(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the pointer of the region of the object.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcxstrsize' is used in order to get the size of the region of an extensible string object.</p>

<dl class="api">
<dt><code>int tcxstrsize(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the size of the region of the object.</dd>
</dl>

<p>The function `tcxstrclear' is used in order to clear an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrclear(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The internal buffer of the object is cleared and the size is set zero.</dd>
</dl>

<p>The function `tcxstrtomalloc' is used in order to convert an extensible string object into a usual allocated region.</p>

<dl class="api">
<dt><code>void *tcxstrtomalloc(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the pointer to the allocated region of the object.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  Because the region of the original object is deleted, it should not be deleted again.</dd>
</dl>

<p>The function `tcxstrfrommalloc' is used in order to create an extensible string object from an allocated region.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrfrommalloc(void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region allocated with `malloc' call.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the new extensible string object wrapping the specified region.</dd>
<dd>Note that the specified region is released when the object is deleted.</dd>
</dl>

<p>The function `tcxstrprintf' is used in order to perform formatted output into an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrprintf(TCXSTR *<var>xstr</var>, const char *<var>format</var>, ...);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
</dl>

<p>The function `tcsprintf' is used in order to allocate a formatted string on memory.</p>

<dl class="api">
<dt><code>char *tcsprintf(const char *<var>format</var>, ...);</code></dt>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3>配列リストのAPI（英語御免）</h3>

<p>The function `tclistnew' is used in order to create a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew(void);</code></dt>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistnew2' is used in order to create a list object with expecting the number of elements.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew2(int <var>anum</var>);</code></dt>
<dd>`<var>anum</var>' specifies the number of elements expected to be stored in the list.</dd>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistdup' is used in order to copy a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistdup(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the new list object equivalent to the specified object.</dd>
</dl>

<p>The function `tclistdel' is used in order to delete a list object.</p>

<dl class="api">
<dt><code>void tclistdel(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tclistnum' is used in order to get the number of elements of a list object.</p>

<dl class="api">
<dt><code>int tclistnum(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the number of elements of the list.</dd>
</dl>

<p>The function `tclistval' is used in order to get the pointer to the region of an element of a list object.</p>

<dl class="api">
<dt><code>const void *tclistval(const TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the value.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistval2' is used in order to get the string of an element of a list object.</p>

<dl class="api">
<dt><code>const char *tclistval2(const TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>The return value is the string of the value.</dd>
<dd>If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpush' is used in order to add an element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistpush2' is used in order to add a string element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistpushmalloc' is used in order to add an allocated element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpushmalloc(TCLIST *<var>list</var>, void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region allocated with `malloc' call.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>Note that the specified region is released when the object is deleted.</dd>
</dl>

<p>The function `tclistpop' is used in order to remove an element of the end of a list object.</p>

<dl class="api">
<dt><code>void *tclistpop(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpop2' is used in order to remove a string element of the end of a list object.</p>

<dl class="api">
<dt><code>char *tclistpop2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistunshift' is used in order to add an element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistunshift2' is used in order to add a string element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistshift' is used in order to remove an element of the top of a list object.</p>

<dl class="api">
<dt><code>void *tclistshift(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistshift2' is used in order to remove a string element of the top of a list object.</p>

<dl class="api">
<dt><code>char *tclistshift2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistinsert' is used in order to add an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistinsert2' is used in order to add a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistremove' is used in order to remove an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void *tclistremove(TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistremove2' is used in order to remove a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>char *tclistremove2(TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistover' is used in order to overwrite an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new content.</dd>
<dd>`<var>size</var>' specifies the size of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistover2' is used in order to overwrite a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>str</var>' specifies the string of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistsort' is used in order to sort elements of a list object in lexical order.</p>

<dl class="api">
<dt><code>void tclistsort(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
</dl>

<p>The function `tclistsortci' is used in order to sort elements of a list object in case-insensitive lexical order.</p>

<dl class="api">
<dt><code>void tclistsortci(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
</dl>

<p>The function `tclistlsearch' is used in order to search a list object for an element using liner search.</p>

<dl class="api">
<dt><code>int tclistlsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, the former returns.</dd>
</dl>

<p>The function `tclistbsearch' is used in order to search a list object for an element using binary search.</p>

<dl class="api">
<dt><code>int tclistbsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.  It should be sorted in lexical order.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, which returns is not defined.</dd>
</dl>

<p>The function `tclistclear' is used in order to clear a list object.</p>

<dl class="api">
<dt><code>void tclistclear(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>All elements are removed.</dd>
</dl>

<p>The function `tclistdump' is used in order to serialize a list object into a byte array.</p>

<dl class="api">
<dt><code>void *tclistdump(const TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tclistload' is used in order to create a list object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCLIST *tclistload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new list object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3>ハッシュマップのAPI（英語御免）</h3>

<p>The function `tcmapnew' is used in order to create a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew(void);</code></dt>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapnew2' is used in order to create a map object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew2(uint32_t <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapdup' is used in order to copy a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapdup(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new map object equivalent to the specified object.</dd>
</dl>

<p>The function `tcmapdel' is used in order to delete a map object.</p>

<dl class="api">
<dt><code>void tcmapdel(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmapput' is used in order to store a record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapput2' is used in order to store a string record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapput3' is used in order to store a record of the value of two regions into a map object.</p>

<dl class="api">
<dt><code>void tcmapput3(TCMAP *<var>map</var>, const char *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>fvbuf</var>, int <var>fvsiz</var>, const char *<var>lvbuf</var>, int <var>lvsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>fvbuf</var>' specifies the pointer to the former region of the value.</dd>
<dd>`<var>fvsiz</var>' specifies the size of the former region of the value.</dd>
<dd>`<var>lvbuf</var>' specifies the pointer to the latter region of the value.</dd>
<dd>`<var>lvsiz</var>' specifies the size of the latter region of the value.</dd>
<dd>If a record with the same key exists in the map, it is overwritten.</dd>
</dl>

<p>The function `tcmapputkeep' is used in order to store a new record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the map, this function has no effect.</dd>
</dl>

<p>The function `tcmapputkeep2' is used in order to store a new string record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the map, this function has no effect.</dd>
</dl>

<p>The function `tcmapputcat' is used in order to concatenate a value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapout' is used in order to remove a record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapout2' is used in order to remove a string record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout2(TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapget' is used in order to retrieve a record in a map object.</p>

<dl class="api">
<dt><code>const void *tcmapget(const TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcmapget2' is used in order to retrieve a string record in a map object.</p>

<dl class="api">
<dt><code>const char *tcmapget2(const TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
</dl>

<p>The function `tcmapget3' is used in order to retrieve a semivolatile record in a map object.</p>

<dl class="api">
<dt><code>const void *tcmapget3(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The internal region of the returned record is moved to the tail so that the record will survive for a time under LRU cache algorithm removing records from the head.</dd>
</dl>

<p>The function `tcmapmove' is used in order to move a record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of a key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>head</var>' specifies the destination which is head if it is true or tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapmove2' is used in order to move a string record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove2(TCMAP *<var>map</var>, const char *<var>kstr</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of a key.</dd>
<dd>`<var>head</var>' specifies the destination which is head if it is true or tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapiterinit' is used in order to initialize the iterator of a map object.</p>

<dl class="api">
<dt><code>void tcmapiterinit(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the map object.</dd>
</dl>

<p>The function `tcmapiternext' is used in order to get the next key of the iterator of a map object.</p>

<dl class="api">
<dt><code>const void *tcmapiternext(TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmapiternext2' is used in order to get the next key string of the iterator of a map object.</p>

<dl class="api">
<dt><code>const char *tcmapiternext2(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmapiterval' is used in order to get the value bound to the key fetched from the iterator of a map object.</p>

<dl class="api">
<dt><code>const void *tcmapiterval(const void *<var>kbuf</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the iteration key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the value of the corresponding record.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcmapiterval2' is used in order to get the value string bound to the key fetched from the iterator of a map object.</p>

<dl class="api">
<dt><code>const char *tcmapiterval2(const char *<var>kstr</var>);</code></dt>
<dd>`<var>kstr</var>' specifies the string of the iteration key.</dd>
<dd>The return value is the pointer to the region of the value of the corresponding record.</dd>
</dl>

<p>The function `tcmaprnum' is used in order to get the number of records stored in a map object.</p>

<dl class="api">
<dt><code>uint64_t tcmaprnum(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the number of the records stored in the map object.</dd>
</dl>

<p>The function `tcmapmsiz' is used in order to get the total size of memory used in a map object.</p>

<dl class="api">
<dt><code>uint64_t tcmapmsiz(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the total size of memory used in a map object.</dd>
</dl>

<p>The function `tcmapkeys' is used in order to create a list object containing all keys in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapkeys(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all keys in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapvals' is used in order to create a list object containing all values in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapvals(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all values in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapaddint' is used in order to add an integer to a record in a map object.</p>

<dl class="api">
<dt><code>void tcmapaddint(TCMAP *<var>map</var>, const char *<var>kbuf</var>, int <var>ksiz</var>, int <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>num</var>' specifies the additional value.</dd>
<dd>If the corresponding record exists, the value is treated as a integer and is added to.  If no record corresponds, a new record of the additional value is stored.</dd>
</dl>

<p>The function `tcmapclear' is used in order to clear a map object.</p>

<dl class="api">
<dt><code>void tcmapclear(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmapcutfront' is used in order to remove front records of a map object.</p>

<dl class="api">
<dt><code>void tcmapcutfront(TCMAP *<var>map</var>, int <var>num</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapdump' is used in order to serialize a map object into a byte array.</p>

<dl class="api">
<dt><code>void *tcmapdump(const TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmapload' is used in order to create a map object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCMAP *tcmapload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new map object.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmaploadone' is used in order to extract a map record from a serialized byte array.</p>

<dl class="api">
<dt><code>void *tcmaploadone(const void *<var>ptr</var>, int <var>size</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<h3>オンメモリデータベースのAPI（英語御免）</h3>

<p>The function `tcmdbnew' is used in order to create an on-memory database object.</p>

<dl class="api">
<dt><code>TCMDB *tcmdbnew(void);</code></dt>
<dd>The return value is the new on-memory database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcmdbnew2' is used in order to create an on-memory database object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMDB *tcmdbnew2(uint32_t <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new on-memory database object.</dd>
<dd>The object can be shared by plural threads because of the internal mutex.</dd>
</dl>

<p>The function `tcmdbdel' is used in order to delete an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbdel(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
</dl>

<p>The function `tcmdbput' is used in order to store a record into an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbput(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbput2' is used in order to store a string record into an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbput2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbput3' is used in order to store a record of the value of two regions into an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbput3(TCMDB *<var>mdb</var>, const char *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>fvbuf</var>, int <var>fvsiz</var>, const char *<var>lvbuf</var>, int <var>lvsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>fvbuf</var>' specifies the pointer to the former region of the value.</dd>
<dd>`<var>fvsiz</var>' specifies the size of the former region of the value.</dd>
<dd>`<var>lvbuf</var>' specifies the pointer to the latter region of the value.</dd>
<dd>`<var>lvsiz</var>' specifies the size of the latter region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmdbputkeep' is used in order to store a new record into an on-memory database object.</p>

<dl class="api">
<dt><code>bool tcmdbputkeep(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmdbputkeep2' is used in order to store a new string record into an on-memory database object.</p>

<dl class="api">
<dt><code>bool tcmdbputkeep2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmdbputcat' is used in order to concatenate a value at the end of the value of the existing record in an on-memory database.</p>

<dl class="api">
<dt><code>void tcmdbputcat(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmdbputcat2' is used in order to concatenate a string at the end of the value of the existing record in an on-memory database.</p>

<dl class="api">
<dt><code>void tcmdbputcat2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmdbout' is used in order to remove a record of an on-memory database object.</p>

<dl class="api">
<dt><code>bool tcmdbout(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmdbout2' is used in order to remove a string record of an on-memory database object.</p>

<dl class="api">
<dt><code>bool tcmdbout2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmdbget' is used in order to retrieve a record in an on-memory database object.</p>

<dl class="api">
<dt><code>void *tcmdbget(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmdbget2' is used in order to retrieve a string record in an on-memory database object.</p>

<dl class="api">
<dt><code>char *tcmdbget2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmdbget3' is used in order to retrieve a record and move it astern in an on-memory database object.</p>

<dl class="api">
<dt><code>void *tcmdbget3(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The internal region of the returned record is moved to the tail so that the record will survive for a time under LRU cache algorithm removing records from the head.</dd>
</dl>

<p>The function `tcmdbvsiz' is used in order to get the size of the value of a record in an on-memory database object.</p>

<dl class="api">
<dt><code>int tcmdbvsiz(TCMDB *<var>mdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcmdbvsiz2' is used in order to get the size of the value of a string record in an on-memory database object.</p>

<dl class="api">
<dt><code>int tcmdbvsiz2(TCMDB *<var>mdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcmdbiterinit' is used in order to initialize the iterator of an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbiterinit(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the on-memory database.</dd>
</dl>

<p>The function `tcmdbiternext' is used in order to get the next key of the iterator of an on-memory database object.</p>

<dl class="api">
<dt><code>void *tcmdbiternext(TCMDB *<var>mdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return</dd>
<dd>value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmdbiternext2' is used in order to get the next key string of the iterator of an on-memory database object.</p>

<dl class="api">
<dt><code>char *tcmdbiternext2(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmdbrnum' is used in order to get the number of records stored in an on-memory database object.</p>

<dl class="api">
<dt><code>uint64_t tcmdbrnum(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>The return value is the number of the records stored in the database.</dd>
</dl>

<p>The function `tcmdbmsiz' is used in order to get the total size of memory used in an on-memory database object.</p>

<dl class="api">
<dt><code>uint64_t tcmdbmsiz(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>The return value is the total size of memory used in the database.</dd>
</dl>

<p>The function `tcmdbvanish' is used in order to clear an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbvanish(TCMDB *<var>mdb</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmdbcutfront' is used in order to remove front records of an on-memory database object.</p>

<dl class="api">
<dt><code>void tcmdbcutfront(TCMDB *<var>mdb</var>, int <var>num</var>);</code></dt>
<dd>`<var>mdb</var>' specifies the on-memory database object.</dd>
<dd>`<var>num</var>' specifies the number of records to be removed.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<h3>メモリプールのAPI（英語御免）</h3>

<p>The function `tcmpoolnew' is used in order to create a memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolnew(void);</code></dt>
<dd>The return value is the new memory pool object.</dd>
</dl>

<p>The function `tcmpooldel' is used in order to delete a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpooldel(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmpoolput' is used in order to relegate an arbitrary object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolput(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>, void (*<var>del</var>)(void *));</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the object to be relegated.</dd>
<dd>`<var>del</var>' specifies the pointer to the function to delete the object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputptr' is used in order to relegate an allocated region to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputptr(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region to be relegated.</dd>
<dd>This function assures that the specified region is released when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputxstr' is used in order to relegate an extensible string object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputxstr(TCMPOOL *<var>mpool</var>, TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputlist' is used in order to relegate a list object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputlist(TCMPOOL *<var>mpool</var>, TCLIST *<var>list</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputmap' is used in order to relegate a map object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputmap(TCMPOOL *<var>mpool</var>, TCMAP *<var>map</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolmalloc' is used in order to allocate a region relegated to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolmalloc(TCMPOOL *<var>mpool</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>The return value is the pointer to the allocated region under the memory pool.</dd>
</dl>

<p>The function `tcmpoolxstrnew' is used in order to create an extensible string object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCXSTR *tcmpoolxstrnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new extensible string object under the memory pool.</dd>
</dl>

<p>The function `tcmpoollistnew' is used in order to create a list object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCLIST *tcmpoollistnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new list object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolmapnew' is used in order to create a map object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCMAP *tcmpoolmapnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new map object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolglobal' is used in order to get the global memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolglobal(void);</code></dt>
<dd>The return value is the global memory pool object.</dd>
<dd>The global memory pool object is a singleton and assured to be deleted when the process is terminating normally.</dd>
</dl>

<h3>雑多なユーティリティのAPI（英語御免）</h3>

<p>The function `tclmax' is used in order to get the larger value of two integers.</p>

<dl class="api">
<dt><code>long tclmax(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the larger value of the two.</dd>
</dl>

<p>The function `tclmin' is used in order to get the lesser value of two integers.</p>

<dl class="api">
<dt><code>long tclmin(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the lesser value of the two.</dd>
</dl>

<p>The function `tclrand' is used in order to get a random number as long integer based on uniform distribution.</p>

<dl class="api">
<dt><code>unsigned long tclrand(void);</code></dt>
<dd>The return value is the random number between 0 and `ULONG_MAX'.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcdrand' is used in order to get a random number as double decimal based on uniform distribution.</p>

<dl class="api">
<dt><code>double tcdrand(void);</code></dt>
<dd>The return value is the random number equal to or greater than 0, and less than 1.0.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcdrandnd' is used in order to get a random number as double decimal based on normal distribution.</p>

<dl class="api">
<dt><code>double tcdrandnd(double <var>avg</var>, double <var>sd</var>);</code></dt>
<dd>`<var>avg</var>' specifies the average.</dd>
<dd>`<var>sd</var>' specifies the standard deviation.</dd>
<dd>The return value is the random number.</dd>
<dd>This function uses the random number source device and generates a real random number if possible.</dd>
</dl>

<p>The function `tcstricmp' is used in order to compare two strings with case insensitive evaluation.</p>

<dl class="api">
<dt><code>int tcstricmp(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
</dl>

<p>The function `tcstrfwm' is used in order to check whether a string begins with a key.</p>

<dl class="api">
<dt><code>bool tcstrfwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrifwm' is used in order to check whether a string begins with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstrifwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrbwm' is used in order to check whether a string ends with a key.</p>

<dl class="api">
<dt><code>bool tcstrbwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstribwm' is used in order to check whether a string ends with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstribwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrdist' is used in order to calculate the edit distance of two strings.</p>

<dl class="api">
<dt><code>int tcstrdist(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by byte.</dd>
</dl>

<p>The function `tcstrdistutf' is used in order to calculate the edit distance of two UTF-8 strings.</p>

<dl class="api">
<dt><code>int tcstrdistutf(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is the edit distance which is known as the Levenshtein distance.  The cost is calculated by Unicode character.</dd>
</dl>

<p>The function `tcstrtoupper' is used in order to convert the letters of a string into upper case.</p>

<dl class="api">
<dt><code>char *tcstrtoupper(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtolower' is used in order to convert the letters of a string into lower case.</p>

<dl class="api">
<dt><code>char *tcstrtolower(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtrim' is used in order to cut space characters at head or tail of a string.</p>

<dl class="api">
<dt><code>char *tcstrtrim(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsqzspc' is used in order to squeeze space characters in a string and trim it.</p>

<dl class="api">
<dt><code>char *tcstrsqzspc(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsubchr' is used in order to substitute characters in a string.</p>

<dl class="api">
<dt><code>char *tcstrsubchr(char *<var>str</var>, const char *<var>rstr</var>, const char *<var>sstr</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>`<var>rstr</var>' specifies the string containing characters to be replaced.</dd>
<dd>`<var>sstr</var>' specifies the string containing characters to be substituted.</dd>
<dd>If the substitute string is shorter then the replacement string, corresponding characters are removed.</dd>
</dl>

<p>The function `tcstrcntutf' is used in order to count the number of characters in a string of UTF-8.</p>

<dl class="api">
<dt><code>int tcstrcntutf(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>The return value is the number of characters in the string.</dd>
</dl>

<p>The function `tcstrcututf' is used in order to cut a string of UTF-8 at the specified number of characters.</p>

<dl class="api">
<dt><code>char *tcstrcututf(char *<var>str</var>, int <var>num</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>`<var>num</var>' specifies the number of characters to be kept.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrutftoucs' is used in order to convert a UTF-8 string into a UCS-2 array.</p>

<dl class="api">
<dt><code>void tcstrutftoucs(const char *<var>str</var>, uint16_t *<var>ary</var>, int *<var>np</var>);</code></dt>
<dd>`<var>str</var>' specifies the UTF-8 string.</dd>
<dd>`<var>ary</var>' specifies the pointer to the region into which the result UCS-2 codes are written.  The size of the buffer should be sufficient.</dd>
<dd>`<var>np</var>' specifies the pointer to a variable into which the number of elements of the result array is assigned.</dd>
</dl>

<p>The function `tcstrucstoutf' is used in order to convert a UCS-2 array into a UTF-8 string.</p>

<dl class="api">
<dt><code>void tcstrucstoutf(const uint16_t *<var>ary</var>, int <var>num</var>, char *<var>str</var>);</code></dt>
<dd>`<var>ary</var>' specifies the array of UCS-2 code codes.</dd>
<dd>`<var>num</var>' specifies the number of the array.</dd>
<dd>`<var>str</var>' specifies the pointer to the region into which the result UTF-8 string is written.  The size of the buffer should be sufficient.</dd>
</dl>

<p>The function `tcstrsplit' is used in order to create a list object by splitting a string.</p>

<dl class="api">
<dt><code>TCLIST *tcstrsplit(const char *<var>str</var>, const char *<var>delims</var>);</code></dt>
<dd>`<var>str</var>' specifies the source string.</dd>
<dd>`<var>delims</var>' specifies a string containing delimiting characters.</dd>
<dd>The return value is a list object of the split elements.</dd>
<dd>If two delimiters are successive, it is assumed that an empty element is between the two.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcstrjoin' is used in order to create a string by joining all elements of a list object.</p>

<dl class="api">
<dt><code>char *tcstrjoin(TCLIST *<var>list</var>, char <var>delim</var>);</code></dt>
<dd>`<var>list</var>' specifies a list object.</dd>
<dd>`<var>delim</var>' specifies a delimiting character.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tctime' is used in order to get the time of day in seconds.</p>

<dl class="api">
<dt><code>double tctime(void);</code></dt>
<dd>The return value is the time of day in seconds.  The accuracy is in microseconds.</dd>
</dl>

<p>The function `tccalendar' is used in order to get the Gregorian calendar of a time.</p>

<dl class="api">
<dt><code>void tccalendar(int64_t <var>t</var>, int <var>jl</var>, int *<var>yearp</var>, int *<var>monp</var>, int *<var>dayp</var>, int *<var>hourp</var>, int *<var>minp</var>, int *<var>secp</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>yearp</var>' specifies the pointer to a variable to which the year is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>monp</var>' specifies the pointer to a variable to which the month is assigned.  If it is `NULL', it is not used.  1 means January and 12 means December.</dd>
<dd>`<var>dayp</var>' specifies the pointer to a variable to which the day of the month is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>hourp</var>' specifies the pointer to a variable to which the hours is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>minp</var>' specifies the pointer to a variable to which the minutes is assigned.  If it is `NULL', it is not used.</dd>
<dd>`<var>secp</var>' specifies the pointer to a variable to which the seconds is assigned.  If it is `NULL', it is not used.</dd>
</dl>

<p>The function `tcdatestrwww' is used in order to format a date as a string in W3CDTF.</p>

<dl class="api">
<dt><code>void tcdatestrwww(int64_t <var>t</var>, int <var>jl</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
<dd>W3CDTF represents a date as "YYYY-MM-DDThh:mm:ddTZD".</dd>
</dl>

<p>The function `tcdatestrhttp' is used in order to format a date as a string in RFC 1123 format.</p>

<dl class="api">
<dt><code>void tcdatestrhttp(int64_t <var>t</var>, int <var>jl</var>, char *<var>buf</var>);</code></dt>
<dd>`<var>t</var>' specifies the source time in seconds from the epoch.  If it is `INT64_MAX', the current time is specified.</dd>
<dd>`<var>jl</var>' specifies the jet lag of a location in seconds.  If it is `INT_MAX', the local jet lag is specified.</dd>
<dd>`<var>buf</var>' specifies the pointer to the region into which the result string is written.  The size of the buffer should be equal to or more than 48 bytes.</dd>
<dd>RFC 1123 format represents a date as "Wdy, DD-Mon-YYYY hh:mm:dd TZD".</dd>
</dl>

<p>The function `tcstrmktime' is used in order to get the time value of a date string.</p>

<dl class="api">
<dt><code>int64_t tcstrmktime(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the date string in decimal, hexadecimal, W3CDTF, or RFC 822 (1123).  Decimal can be trailed by "s" for in seconds, "m" for in minutes, "h" for in hours, and "d" for in days.</dd>
<dd>The return value is the time value of the date or `INT64_MAX' if the format is invalid.</dd>
</dl>

<p>The function `tcdayofweek' is used in order to get the day of week of a date.</p>

<dl class="api">
<dt><code>int tcdayofweek(int <var>year</var>, int <var>mon</var>, int <var>day</var>);</code></dt>
<dd>`<var>year</var>' specifies the year of a date.</dd>
<dd>`<var>mon</var>' specifies the month of the date.</dd>
<dd>`<var>day</var>' specifies the day of the date.</dd>
<dd>The return value is the day of week of the date.  0 means Sunday and 6 means Saturday.</dd>
</dl>

<h3>ファイルシステム関連ユーティリティのAPI（英語御免）</h3>

<p>The function `tcrealpath' is used in order to get the canonicalized absolute path of a file.</p>

<dl class="api">
<dt><code>char *tcrealpath(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.</dd>
<dd>The return value is the canonicalized absolute path of a file, or `NULL' if the path is invalid.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcreadfile' is used in order to read whole data of a file.</p>

<dl class="api">
<dt><code>void *tcreadfile(const char *<var>path</var>, int <var>limit</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>`<var>limit</var>' specifies the limiting size of reading data.  If it is not more than 0, the limitation is not specified.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.  If it is `NULL', it is not used.</dd>
<dd>The return value is the pointer to the allocated region of the read data, or `NULL' if the file could not be opened.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when when is no longer in use.</dd>
</dl>

<p>The function `tcreadfilelines' is used in order to read every line of a file.</p>

<dl class="api">
<dt><code>TCLIST *tcreadfilelines(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>The return value is a list object of every lines if successful, else it is `NULL'.</dd>
<dd>Line separators are cut out.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcwritefile' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwritefile(const char *<var>path</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard output is specified.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the data region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tccopyfile' is used in order to copy a file.</p>

<dl class="api">
<dt><code>bool tccopyfile(const char *<var>src</var>, const char *<var>dest</var>);</code></dt>
<dd>`<var>src</var>' specifies the path of the source file.</dd>
<dd>`<var>dest</var>' specifies the path of the destination file.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
<dd>If the destination file exists, it is overwritten.</dd>
</dl>

<p>The function `tcreaddir' is used in order to read names of files in a directory.</p>

<dl class="api">
<dt><code>TCLIST *tcreaddir(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the directory.</dd>
<dd>The return value is a list object of names if successful, else it is `NULL'.</dd>
<dd>Links to the directory itself and to the parent directory are ignored.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcremovelink' is used in order to remove a file or a directory and its sub ones recursively.</p>

<dl class="api">
<dt><code>bool tcremovelink(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the link.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the link does not exist or the permission is denied.</dd>
</dl>

<p>The function `tcwrite' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwrite(int <var>fd</var>, const void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to be written.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcread' is used in order to read data from a file.</p>

<dl class="api">
<dt><code>bool tcread(int <var>fd</var>, void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to store into.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tclock' is used in order to lock a file.</p>

<dl class="api">
<dt><code>bool tclock(int <var>fd</var>, bool <var>ex</var>, bool <var>nb</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>ex</var>' specifies whether an exclusive lock or a shared lock is performed.</dd>
<dd>`<var>nb</var>' specifies whether to request with non-blocking.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<h3>エンコード関連ユーティリティのAPI（英語御免）</h3>

<p>The function `tcurlencode' is used in order to encode a serial object with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurlencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcurldecode' is used in order to decode a string encoded with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurldecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcurlbreak' is used in order to break up a URL into elements.</p>

<dl class="api">
<dt><code>TCMAP *tcurlbreak(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the URL string.</dd>
<dd>The return value is the map handle whose keys are the name of elements.  The key "self" specifies the URL itself.  The key "scheme" specifies the scheme.  The key "host" specifies the host of the server.  The key "port" specifies the port number of the server.  The key "authority" specifies the authority information.  The key "path" specifies the path of the resource.  The key "file" specifies the file name without the directory section.  The key "query" specifies the query string.  The key "fragment" specifies the fragment string.</dd>
<dd>Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcurlresolve' is used in order to resolve a relative URL with an absolute URL.</p>

<dl class="api">
<dt><code>char *tcurlresolve(const char *<var>base</var>, const char *<var>target</var>);</code></dt>
<dd>`<var>base</var>' specifies the absolute URL of the base location.</dd>
<dd>`<var>target</var>' specifies the URL to be resolved.</dd>
<dd>The return value is the resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbaseencode' is used in order to encode a serial object with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbaseencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcbasedecode' is used in order to decode a string encoded with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbasedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcquoteencode' is used in order to encode a serial object with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquoteencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcquotedecode' is used in order to decode a string encoded with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquotedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimeencode' is used in order to encode a string with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimeencode(const char *<var>str</var>, const char *<var>encname</var>, bool <var>base</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>`<var>encname</var>' specifies the string of the name of the character encoding.</dd>
<dd>`<var>base</var>' specifies whether to use Base64 encoding.  If it is false, Quoted-printable is used.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimedecode' is used in order to decode a string encoded with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimedecode(const char *<var>str</var>, char *<var>enp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>enp</var>' specifies the pointer to the region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackencode' is used in order to compress a serial object with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackdecode' is used in order to decompress a serial object compressed with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsencode' is used in order to compress a serial object with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsdecode' is used in order to decompress a serial object compressed with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcdeflate' is used in order to compress a serial object with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcdeflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcinflate' is used in order to decompress a serial object compressed with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcinflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipencode' is used in order to compress a serial object with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipdecode' is used in order to decompress a serial object compressed with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgetcrc' is used in order to get the CRC32 checksum of a serial object.</p>

<dl class="api">
<dt><code>unsigned int tcgetcrc(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the CRC32 checksum of the object.</dd>
</dl>

<p>The function `tcberencode' is used in order to encode an array of nonnegative integers with BER encoding.</p>

<dl class="api">
<dt><code>char *tcberencode(const unsigned int *<var>ary</var>, int <var>anum</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ary</var>' specifies the pointer to the array of nonnegative integers.</dd>
<dd>`<var>anum</var>' specifies the size of the array.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcberdecode' is used in order to decode a serial object encoded with BER encoding.</p>

<dl class="api">
<dt><code>unsigned int *tcberdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>np</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>np</var>' specifies the pointer to a variable into which the number of elements of the return value is assigned.</dd>
<dd>The return value is the pointer to the array of the result.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcxmlescape' is used in order to escape meta characters in a string with the entity references of XML.</p>

<dl class="api">
<dt><code>char *tcxmlescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the pointer to the escaped string.</dd>
<dd>This function escapes only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcxmlunescape' is used in order to unescape entity references in a string of XML.</p>

<dl class="api">
<dt><code>char *tcxmlunescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the unescaped string.</dd>
<dd>This function restores only `&amp;amp;', `&amp;lt;', `&amp;gt;', and `&amp;quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcxmlbreak' is used in order to split an XML string into tags and text sections.</p>

<dl class="api">
<dt><code>TCLIST *tcxmlbreak(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the XML string.</dd>
<dd>The return value is the list object whose elements are strings of tags or text sections.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Because this function does not check validation, it can handle also HTML and SGML.</dd>
</dl>

<p>The function `tcxmlattrs' is used in order to get the map of attributes of an XML tag.</p>

<dl class="api">
<dt><code>TCMAP *tcxmlattrs(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the pointer to the region of a tag string.</dd>
<dd>The return value is the map object containing attribute names and their values which are unescaped.  You can get the name of the tag with the key of an empty string.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<h3>コード例</h3>

<p>拡張可能文字列と配列リストとハッシュマップを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv){

  { /* 拡張可能文字列オブジェクトの使用例 */
    TCXSTR *xstr;
    /* オブジェクトを作成する */
    xstr = tcxstrnew();
    /* 文字列を連結する */
    tcxstrcat2(xstr, "hop");
    tcxstrcat2(xstr, "step");
    tcxstrcat2(xstr, "jump");
    /* サイズと内容を印字する */
    printf("%d:%s\n", tcxstrsize(xstr), (char *)tcxstrptr(xstr));
    /* オブジェクトを破棄する */
    tcxstrdel(xstr);
  }

  { /* リストオブジェクトの使用例 */
    TCLIST *list;
    int i;
    /* オブジェクトを作成する */
    list = tclistnew();
    /* 末尾に文字列を追加する */
    tclistpush2(list, "hop");
    tclistpush2(list, "step");
    tclistpush2(list, "jump");
    /* 全ての要素を印字する */
    for(i = 0; i &lt; tclistnum(list); i++){
      printf("%d:%s\n", i, tclistval2(list, i));
    }
    /* オブジェクトを破棄する */
    tclistdel(list);
  }

  { /* マップオブジェクトの使用例 */
    TCMAP *map;
    const char *key;
    /* オブジェクトを作成する */
    map = tcmapnew();
    /* レコードを追加する */
    tcmapput2(map, "foo", "hop");
    tcmapput2(map, "bar", "step");
    tcmapput2(map, "baz", "jump");
    /* 全てのレコードを印字する */
    tcmapiterinit(map);
    while((key = tcmapiternext2(map)) != NULL){
      printf("%s:%s\n", key, tcmapget2(map, key));
    }
    /* オブジェクトを破棄する */
    tcmapdel(map);
  }

  return 0;
}
</pre>

<h3>CLI</h3>

<p>ユーティリティAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcutest</code>' と `<code>tcumttest</code>'  と `<code>tcucodec</code>' が提供されます。</p>

<p>コマンド `<code>tcutest</code>' は、ユーティリティAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>rnum</var>' は試行回数を指定し、`<var>anum</var>' は配列の初期容量を指定し、`<var>bnum</var>' はバケット数を指定します。</p>

<dl class="api">
<dt><code>tcutest xstr <var>rnum</var></code></dt>
<dd>拡張可能文字列に文字列を連結するテストを行います。</dd>
<dt><code>tcutest list <var>rnum</var> [<var>anum</var>]</code></dt>
<dd>配列リストに要素を追加するテストを行います。</dd>
<dt><code>tcutest map <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>ハッシュマップにレコードを追加するテストを行います。</dd>
<dt><code>tcutest mdb <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>オンメモリデータベースにレコードを追加するテストを行います。</dd>
<dt><code>tcutest misc <var>rnum</var></code></dt>
<dd>その他の雑多なテストを行います。</dd>
<dt><code>tcutest wicked <var>rnum</var></code></dt>
<dd>配列リストとハッシュマップの各種更新操作を無作為に選択して実行するテストを行います。</dd>
</dl>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcumttest</code>' は、オンメモリデータベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定します。</p>

<dl class="api">
<dt><code>tcumttest combo [-rnd] <var>tnum</var> <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>レコードの格納と検索と削除を順に実行する。</dd>
<dt><code>tcumttest typical [-nc] [-rr <var>num</var>] <var>tnum</var> <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcucodec</code>' は、ユーティリティAPIが提供するエンコードおよびデコードの機能を利用するツールです。以下の書式で用います。`<var>file</var>' は入力ファイルを指定しますが、省略されれば標準入力を読み込みます。</p>

<dl class="api">
<dt><code>tcucodec url [-d] [-br] [-rs <var>base</var>] [<var>file</var>]</code></dt>
<dd>URLエンコードとそのデコードを行う。</dd>
<dt><code>tcucodec base [-d] [<var>file</var>]</code></dt>
<dd>Base64エンコードとそのデコードを行う。</dd>
<dt><code>tcucodec quote [-d] [<var>file</var>]</code></dt>
<dd>Quoted-printableエンコードとそのデコードを行う。</dd>
<dt><code>tcucodec mime [-d] [-en <var>name</var>] [-q] [<var>file</var>]</code></dt>
<dd>MIMEエンコードとそのデコードを行う。</dd>
<dt><code>tcucodec pack [-d] [-bwt] [<var>file</var>]</code></dt>
<dd>Packbitsの圧縮とその伸長を行う。</dd>
<dt><code>tcucodec tcbs [-d] [<var>file</var>]</code></dt>
<dd>TCBSの圧縮とその伸長を行う。</dd>
<dt><code>tcucodec zlib [-d] [-gz] [<var>file</var>]</code></dt>
<dd>ZLIBの圧縮とその伸長を行う。</dd>
<dt><code>tcucodec xml [-d] [-br] [<var>file</var>]</code></dt>
<dd>XMLの処理を行う。デフォルトではメタ文字のエスケープを行う。</dd>
<dt><code>tcucodec ucs [-d] [<var>file</var>]</code></dt>
<dd>UTF-8の文字列をUCS-2の配列に変換する。</dd>
<dt><code>tcucodec date [-ds <var>str</var>] [-jl <var>num</var>] [-wf] [-rf]</code></dt>
<dd>時刻の書式変換を行う。デフォルトでは現在のUNIX時間を出力する。</dd>
<dt><code>tcucodec conf [-v|-i|-l|-p]</code></dt>
<dd>各種の設定情報を出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます。</p>

<ul class="options">
<li><code>-d</code> : エンコード（エスケープ）ではなく、デコード（アンエスケープ）を行う。</li>
<li><code>-br</code> : URLやXMLを構成要素に分解する。</li>
<li><code>-rs <var>base</var></code> : ベースURLを指定して、相対URLを解決する。</li>
<li><code>-en <var>name</var></code> : 入力の文字コードを指定する。デフォルトはUTF-8である。</li>
<li><code>-q</code> : Quoted-printableエンコードを用いる。デフォルトはBase64である。</li>
<li><code>-bwt</code> : 前処理としてBWTを用いる。</li>
<li><code>-gz</code> : GZIP形式を用いる。</li>
<li><code>-ds <var>str</var></code> : 時刻を指定する。</li>
<li><code>-jl <var>num</var></code> : 時差を指定する。</li>
<li><code>-wf</code> : 出力をW3CDTF形式にする。</li>
<li><code>-rf</code> : 出力をRFC 1123形式にする。</li>
<li><code>-v</code> : Tokyo Cabinetのバージョン番号を表示する。</li>
<li><code>-i</code> : Tokyo Cabinetのヘッダのインクルードオプションを表示する。</li>
<li><code>-l</code> : Tokyo Cabinetのライブラリのリンクオプションを表示する。</li>
<li><code>-p</code> : Tokyo Cabinetのコマンドのあるディレクトリを表示する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tchdbapi">ハッシュデータベースAPI</h2>

<p>ハッシュデータベースは、ハッシュ表を単一のファイルに記録したデータベースです。それを扱うのがハッシュデータベースAPIです。`<code>tchdb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3>概要</h3>

<p>ハッシュデータベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tchdb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tchdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>ハッシュデータベースを扱う際には、`<code>TCHDB</code>' 型へのポインタをオブジェクトとして用います。ハッシュデータベースオブジェクトは、関数 `<code>tchdbnew</code>' で作成し、関数 `<code>tchdbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、ハッシューデータベースオブジェクトをデータベースファイルと接続させる必要があります。データベースファイルを開いて接続するには関数 `<code>tchdbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tchdbclose</code>' を用います。開いたデータベースファイルは必ず閉じてください。そうしないとデータベースファイルが壊れたり格納したデータが失われたりする可能性があります。</p>

<h3>API（英語ゴメン）</h3>

<p>The function `tchdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tchdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tchdbnew' is used in order to create a hash database object.</p>

<dl class="api">
<dt><code>TCHDB *tchdbnew(void);</code></dt>
<dd>The return value is the new hash database object.</dd>
</dl>

<p>The function `tchdbdel' is used in order to delete a hash database object.</p>

<dl class="api">
<dt><code>void tchdbdel(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tchdbecode' is used in order to get the last happened error code of a hash database object.</p>

<dl class="api">
<dt><code>int tchdbecode(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error code is defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tchdbsetmutex' is used in order to set mutual exclusion control of a hash database object for threading.</p>

<dl class="api">
<dt><code>bool tchdbsetmutex(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should should be called before the database is opened.</dd>
</dl>

<p>The function `tchdbtune' is used in order to set the tuning parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtune(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 16381.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbsetcache' is used in order to set the caching parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbsetcache(TCHDB *<var>hdb</var>, int32_t <var>rcnum</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>rcnum</var>' specifies the maximum number of records to be cached.  If it is not more than 0, the record cache is disabled.  It is disabled by default.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbopen' is used in order to open a database file and connect a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbopen(TCHDB *<var>hdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `HDBOWRITER' as a writer, `HDBOREADER' as a reader.  If the mode is `HDBOWRITER', the following may be added by bitwise or: `HDBOCREAT', which means it creates a new database if not exist, `HDBOTRUNC', which means it creates a new database regardless if one exists.  Both of `HDBOREADER' and `HDBOWRITER' can be added to by bitwise or: `HDBONOLCK', which means it opens the database file without file locking, or `HDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbclose' is used in order to close a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbclose(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tchdbput' is used in order to store a record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbput2' is used in order to store a string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbputkeep' is used in order to store a new record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputkeep2' is used in order to store a new string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputcat' is used in order to concatenate a value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputcat2' is used in order to concatenate a string value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputasync' is used in order to store a record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbputasync2' is used in order to store a string record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbout' is used in order to remove a record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbout2' is used in order to remove a string record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbget' is used in order to retrieve a record in a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbget(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget2' is used in order to retrieve a string record in a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbget2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget3' is used in order to retrieve a record in a hash database object and write the value into a buffer.</p>

<dl class="api">
<dt><code>int tchdbget3(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, void *<var>vbuf</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the buffer into which the value of the corresponding record is written.</dd>
<dd>`<var>max</var>' specifies the size of the buffer.</dd>
<dd>If successful, the return value is the size of the written data, else, it is -1.  -1 is returned if no record corresponds to the specified key.</dd>
<dd>Note that an additional zero code is not appended at the end of the region of the writing buffer.</dd>
</dl>

<p>The function `tchdbvsiz' is used in order to get the size of the value of a record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbvsiz2' is used in order to get the size of the value of a string record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbiterinit' is used in order to initialize the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiterinit(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tchdbiternext' is used in order to get the next key of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbiternext(TCHDB *<var>hdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext2' is used in order to get the next key string of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbiternext2(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext3' is used in order to get the next extensible objects of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiternext3(TCHDB *<var>hdb</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the next key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the next value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when no record is to be get out of the iterator.</dd>
</dl>

<p>The function `tchdbsync' is used in order to synchronize updated contents of a hash database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tchdbsync(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects the same database file.</dd>
</dl>

<p>The function `tchdboptimize' is used in order to optimize the file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdboptimize(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tchdbvanish' is used in order to remove all records of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbvanish(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbcopy' is used in order to copy the database file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbcopy(TCHDB *<var>hdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tchdbpath' is used in order to get the file path of a hash database object.</p>

<dl class="api">
<dt><code>const char *tchdbpath(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbrnum' is used in order to get the number of records of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbrnum(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbfsiz' is used in order to get the size of the database file of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbfsiz(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<h3>コード例</h3>

<p>ハッシュデータベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tchdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){

  TCHDB *hdb;
  int ecode;
  char *key, *value;

  /* オブジェクトを作成する */
  hdb = tchdbnew();

  /* データベースを開く */
  if(!tchdbopen(hdb, "casket.hdb", HDBOWRITER | HDBOCREAT)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "open error: %s\n", tchdberrmsg(ecode));
  }

  /* レコードを格納する */
  if(!tchdbput2(hdb, "foo", "hop") ||
     !tchdbput2(hdb, "bar", "step") ||
     !tchdbput2(hdb, "baz", "jump")){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "put error: %s\n", tchdberrmsg(ecode));
  }

  /* レコードを取得する */
  value = tchdbget2(hdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tchdbecode(hdb);
    fprintf(stderr, "get error: %s\n", tchdberrmsg(ecode));
  }

  /* 横断的にレコードを参照する */
  tchdbiterinit(hdb);
  while((key = tchdbiternext2(hdb)) != NULL){
    value = tchdbget2(hdb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* データベースを閉じる */
  if(!tchdbclose(hdb)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "close error: %s\n", tchdberrmsg(ecode));
  }

  /* オブジェクトを破棄する */
  tchdbdel(hdb);

  return 0;
}
</pre>

<h3>CLI</h3>

<p>ハッシュデータベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tchtest</code>' と `<code>tchmttest</code>' と `<code>tchmgr</code>' が提供されます。</p>

<p>コマンド `<code>tchtest</code>' は、ハッシュデータベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tchtest write [-mt] [-tl] [-td|-tb] [-rc <var>num</var>] [-nl|-nb] [-as] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tchtest read [-mt] [-rc <var>num</var>] [-nl|-nb] [-wb] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tchtest remove [-mt] [-rc <var>num</var>] [-nl|-nb] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tchtest rcat [-mt] [-tl] [-td|-tb] [-rc <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-rl] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tchtest misc [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tchtest wicked [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-mt</code> : 関数 `tchdbsetmutex' を呼び出す。</li>
<li><code>-tl</code> : オプション `HDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `HDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `HDBTTCBS' を有効にする。</li>
<li><code>-rc <var>num</var></code> : レコード用キャッシュの最大数を指定する。</li>
<li><code>-nl</code> : オプション `HDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `HDBLCKNB' を有効にする。</li>
<li><code>-as</code> : 関数 `tchdbput' の代わりに関数 `tchdbputasync' を用いる。</li>
<li><code>-wb</code> : 関数 `tchdbget' の代わりに関数 `tchdbget3' を用いる。</li>
<li><code>-pn <var>num</var></code> : パターン数を指定する。</li>
<li><code>-rl</code> : 値を無作為な長さにする。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tchmttest</code>' は、ハッシュデータベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>tnum</var>' はスレッド数を指定し、`<var>rnum</var>' は試行回数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tchmttest write [-tl] [-td|-tb] [-nl|-nb] [-as] [-rnd] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tchmttest read [-rc <var>num</var>] [-nl|-nb] [-wb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tchmttest remove [-nl|-nb] [-rnd] <var>path</var> <var>tnum</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tchmttest wicked [-tl] [-td|-tb] [-nl|-nb] [-nc] <var>path</var> <var>tnum</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tchmttest typical [-tl] [-td|-tb] [-rc <var>num</var>] [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>tnum</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `HDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `HDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `HDBTTCBS' を有効にする。</li>
<li><code>-rc <var>num</var></code> : レコード用キャッシュの最大数を指定する。</li>
<li><code>-nl</code> : オプション `HDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `HDBLCKNB' を有効にする。</li>
<li><code>-as</code> : 関数 `tchdbput' の代わりに関数 `tchdbputasync' を用いる。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tchdbget' の代わりに関数 `tchdbget3' を用いる。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tchmgr</code>' は、ハッシュデータベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定し、`<var>file</var>' は入力ファイルを指定します。</p>

<dl class="api">
<dt><code>tchmgr create [-tl] [-td|-tb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースファイルを作成する。</dd>
<dt><code>tchmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tchmgr put [-nl|-nb] [-sx] [-dk|-dc] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tchmgr out [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tchmgr get [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tchmgr list [-nl|-nb] [-m <var>num</var>] [-pv] [-px] <var>path</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tchmgr optimize [-tl] [-td|-tb] [-tz] [-nl|-nb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tchmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>TSVファイルの各行をキーと値とみなしてレコードを登録する。</dd>
<dt><code>tchmgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `HDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `HDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `HDBTTCBS' を有効にする。</li>
<li><code>-nl</code> : オプション `HDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `HDBLCKNB' を有効にする。</li>
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tchdbput' の代わりに関数 `tchdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tchdbput' の代わりに関数 `tchdbputcat' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-tz</code> : オプション `UINT8_MAX' を有効にする。</li>
<li><code>-sc</code> : キーを小文字に正規化する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tcbdbapi">B+木データベースAPI</h2>

<p>B+木データベースは、B+木を単一のファイルに記録したデータベースです。それを扱うのがB+木データベースAPIです。`<code>tcbdb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3>概要</h3>

<p>ハッシュデータベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tcbdb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcbdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>B+木データベースを扱う際には、`<code>TCBDB</code>' 型へのポインタをオブジェクトとして用います。B+木データベースオブジェクトは、関数 `<code>tcbdbnew</code>' で作成し、関数 `<code>tcbdbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、B+木ーデータベースオブジェクトをデータベースファイルと接続させる必要があります。データベースファイルを開いて接続するには関数 `<code>tcbdbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tcbdbclose</code>' を用います。開いたデータベースファイルは必ず閉じてください。そうしないとデータベースファイルが壊れたり格納したデータが失われたりする可能性があります。</p>

<h3>API（英語ゴメソ）</h3>

<p>The function `tcbdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcbdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
<dd>The return value is the message string of the error code.</dd>
</dl>

<p>The function `tcbdbnew' is used in order to create a B+ tree database object.</p>

<dl class="api">
<dt><code>TCBDB *tcbdbnew(void);</code></dt>
<dd>The return value is the new B+ tree database object.</dd>
</dl>

<p>The function `tcbdbdel' is used in order to delete a B+ tree database object.</p>

<dl class="api">
<dt><code>void tcbdbdel(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcbdbecode' is used in order to get the last happened error code of a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbecode(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error code is defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcbdbsetmutex' is used in order to set mutual exclusion control of a B+ tree database object for threading.</p>

<dl class="api">
<dt><code>bool tcbdbsetmutex(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control is needed if the object is shared by plural threads and this function should should be called before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcmpfunc' is used in order to set the custom comparison function of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcmpfunc(TCBDB *<var>bdb</var>, BDBCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tcbdbcmplexical' (dafault), `tcbdbcmpdecimal', `tcbdbcmpint32', and `tcbdbcmpint64' are built-in.  Note that the comparison function should be set before the database is opened.  Moreover, user-defined comparison functions should be set every time the database is being opened.</dd>
</dl>

<p>The function `tcbdbtune' is used in order to set the tuning parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtune(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the default value is specified.  The default value is 128.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the default value is specified.  The default value is 256.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 16381.  Suggested size of the bucket array is about from 1 to 4 times of the number of all pages to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 8 standing for 2^8=256.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each page is compressed with Deflate encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcache' is used in order to set the caching parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcache(TCBDB *<var>bdb</var>, int32_t <var>lcnum</var>, int32_t <var>ncnum</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lcnum</var>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 1024.</dd>
<dd>`<var>ncnum</var>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.  The default value is 512.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the caching parameters should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbopen' is used in order to open a database file and connect a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbopen(TCBDB *<var>bdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `BDBOWRITER' as a writer, `BDBOREADER' as a reader.  If the mode is `BDBOWRITER', the following may be added by bitwise or: `BDBOCREAT', which means it creates a new database if not exist, `BDBOTRUNC', which means it creates a new database regardless if one exists.  Both of `BDBOREADER' and `BDBOWRITER' can be added to by bitwise or: `BDBONOLCK', which means it opens the database file without file locking, or `BDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbclose' is used in order to close a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbclose(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcbdbput' is used in order to store a record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbput2' is used in order to store a string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbputkeep' is used in order to store a new record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputkeep2' is used in order to store a new string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputcat' is used in order to concatenate a value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputcat2' is used in order to concatenate a stirng value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputdup' is used in order to store a record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup2' is used in order to store a string record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup3' is used in order to store records into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const TCLIST *<var>vals</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the common key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the common key.</dd>
<dd>`<var>vals</var>' specifies a list object containing values.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new records are placed after the existing one.</dd>
</dl>

<p>The function `tcbdbout' is used in order to remove a record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbout2' is used in order to remove a string record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbout3' is used in order to remove records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, all of them are removed.</dd>
</dl>

<p>The function `tcbdbget' is used in order to retrieve a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>void *tcbdbget(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget2' is used in order to retrieve a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>char *tcbdbget2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget3' is used in order to retrieve a record in a B+ tree database object as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbget3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbget4' is used in order to retrieve records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbget4(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is a list object of the values of the corresponding records.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbvnum' is used in order to get the number of records corresponding a key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvnum2' is used in order to get the number of records corresponding a string key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvsiz' is used in order to get the size of the value of a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbvsiz2' is used in order to get the size of the value of a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the first one is selected.</dd>
</dl>

<p>The function `tcbdbrange' is used in order to get keys of ranged records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange(TCBDB *<var>bdb</var>, const void *<var>bkbuf</var>, int <var>bksiz</var>, bool <var>binc</var>, const void *<var>ekbuf</var>, int <var>eksiz</var>, bool <var>einc</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>bkbuf</var>' specifies the pointer to the region of the key of the beginning border.  If it is `NULL', the first record is specified.</dd>
<dd>`<var>bksiz</var>' specifies the size of the region of the beginning key.</dd>
<dd>`<var>binc</var>' specifies whether the beginning border is inclusive or not.</dd>
<dd>`<var>ekbuf</var>' specifies the pointer to the region of the key of the ending border.  If it is `NULL', the last record is specified.</dd>
<dd>`<var>eksiz</var>' specifies the size of the region of the ending key.</dd>
<dd>`<var>einc</var>' specifies whether the ending border is inclusive or not.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbrange2' is used in order to get string keys of ranged records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange2(TCBDB *<var>bdb</var>, const char *<var>bkstr</var>, bool <var>binc</var>, const char *<var>ekstr</var>, bool <var>einc</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>bkstr</var>' specifies the string of the key of the beginning border.  If it is `NULL', the first record is specified.</dd>
<dd>`<var>binc</var>' specifies whether the beginning border is inclusive or not.</dd>
<dd>`<var>ekstr</var>' specifies the string of the key of the ending border.  If it is `NULL', the last record is specified.</dd>
<dd>`<var>einc</var>' specifies whether the ending border is inclusive or not.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbrange3' is used in order to get forward matching keys in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbrange3(TCBDB *<var>bdb</var>, const char *<var>prefix</var>, int <var>max</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>prefix</var>' specifies the prefix of the corresponding keys.</dd>
<dd>`<var>max</var>' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.</dd>
<dd>The return value is a list object of the keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbsync' is used in order to synchronize updated contents of a B+ tree database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcbdbsync(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects the same database file.</dd>
</dl>

<p>The function `tcbdboptimize' is used in order to optimize the file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdboptimize(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of pages.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.  If it is `UINT8_MAX', the current setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tcbdbvanish' is used in order to remove all records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbvanish(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbcopy' is used in order to copy the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbcopy(TCBDB *<var>bdb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.</dd>
</dl>

<p>The function `tcbdbtranbegin' is used in order to begin the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranbegin(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcbdbtrancommit' is used in order to commit the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtrancommit(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcbdbtranabort' is used in order to abort the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranabort(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcbdbpath' is used in order to get the file path of a B+ tree database object.</p>

<dl class="api">
<dt><code>const char *tcbdbpath(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbrnum' is used in order to get the number of records of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbrnum(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbfsiz' is used in order to get the size of the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbfsiz(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbcurnew' is used in order to create a cursor object.</p>

<dl class="api">
<dt><code>BDBCUR *tcbdbcurnew(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the new cursor object.</dd>
<dd>Note that the cursor is available only after initialization with the `tcbdbcurfirst' or the `tcbdbcurjump' functions and so on.  Moreover, the position of the cursor will be indefinite when the database is updated after the initialization of the cursor.</dd>
</dl>

<p>The function `tcbdbcurdel' is used in order to delete a cursor object.</p>

<dl class="api">
<dt><code>void tcbdbcurdel(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
</dl>

<p>The function `tcbdbcurfirst' is used in order to move a cursor object to the first record.</p>

<dl class="api">
<dt><code>bool tcbdbcurfirst(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurlast' is used in order to move a cursor object to the last record.</p>

<dl class="api">
<dt><code>bool tcbdbcurlast(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurjump' is used in order to move a cursor object to the front of records corresponding a key.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump(BDBCUR *<var>cur</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurjump2' is used in order to move a cursor object to the front of records corresponding a key string.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump2(BDBCUR *<var>cur</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurprev' is used in order to move a cursor object to the previous record.</p>

<dl class="api">
<dt><code>bool tcbdbcurprev(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no previous record.</dd>
</dl>

<p>The function `tcbdbcurnext' is used in order to move a cursor object to the next record.</p>

<dl class="api">
<dt><code>bool tcbdbcurnext(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no next record.</dd>
</dl>

<p>The function `tcbdbcurput' is used in order to insert a record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput(BDBCUR *<var>cur</var>, const void *<var>vbuf</var>, int <var>vsiz</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurput2' is used in order to insert a string record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput2(BDBCUR *<var>cur</var>, const char *<var>vstr</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurout' is used in order to delete the record where a cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurout(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After deletion, the cursor is moved to the next record if possible.</dd>
</dl>

<p>The function `tcbdbcurkey' is used in order to get the key of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurkey(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey2' is used in order to get the key string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurkey2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey3' is used in order to get the key of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const char *tcbdbcurkey3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurval' is used in order to get the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurval(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval2' is used in order to get the value string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurval2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval3' is used in order to get the value of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const char *tcbdbcurval3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurrec' is used in order to get the key and the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurrec(BDBCUR *<var>cur</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
</dl>

<h3>コード例</h3>

<p>B+木データベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcbdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){

  TCBDB *bdb;
  BDBCUR *cur;
  int ecode;
  char *key, *value;

  /* オブジェクトを作成する */
  bdb = tcbdbnew();

  /* データベースを開く */
  if(!tcbdbopen(bdb, "casket.bdb", BDBOWRITER | BDBOCREAT)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "open error: %s\n", tcbdberrmsg(ecode));
  }

  /* レコードを格納する */
  if(!tcbdbput2(bdb, "foo", "hop") ||
     !tcbdbput2(bdb, "bar", "step") ||
     !tcbdbput2(bdb, "baz", "jump")){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "put error: %s\n", tcbdberrmsg(ecode));
  }

  /* レコードを取得する */
  value = tcbdbget2(bdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "get error: %s\n", tcbdberrmsg(ecode));
  }

  /* 横断的にレコードを参照する */
  cur = tcbdbcurnew(bdb);
  tcbdbcurfirst(cur);
  while((key = tcbdbcurkey2(cur)) != NULL){
    value = tcbdbcurval2(cur);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
    tcbdbcurnext(cur);
  }
  tcbdbcurdel(cur);

  /* データベースを閉じる */
  if(!tcbdbclose(bdb)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "close error: %s\n", tcbdberrmsg(ecode));
  }

  /* オブジェクトを破棄する */
  tcbdbdel(bdb);

  return 0;
}
</pre>

<h3>CLI</h3>

<p>B+木データベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcbtest</code>' と `<code>tcbmttest</code>' と `<code>tcbmgr</code>' が提供されます。</p>

<p>コマンド `<code>tcbtest</code>' は、B+木データベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>lmemb</var>' はリーフ内メンバ数を指定し、`<var>nmemb</var>' は非リーフ内メンバ数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tcbtest write [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb] [-lc <var>num</var>] [-nc <var>num</var>] [-ls <var>num</var>] [-nl|-nb] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcbtest read [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-nl|-nb] [-wb] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcbtest remove [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-nl|-nb] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcbtest rcat [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb] [-lc <var>num</var>] [-nc <var>num</var>] [-ls <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-rl] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tcbtest queue [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb] [-lc <var>num</var>] [-nc <var>num</var>] [-ls <var>num</var>] [-nl|-nb] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>キューの出し入れを行う。</dd>
<dt><code>tcbtest misc [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tcbtest wicked [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-mt</code> : 関数 `tcbdbsetmutex' を呼び出す。</li>
<li><code>-cd</code> : 比較関数 `tcbdbcmpdecimal' を利用する。</li>
<li><code>-ci</code> : 比較関数 `tcbdbcmpint32' を利用する。</li>
<li><code>-cj</code> : 比較関数 `tcbdbcmpint64' を利用する。</li>
<li><code>-tl</code> : オプション `BDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `BDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `BDBTTCBS' を有効にする。</li>
<li><code>-lc <var>num</var></code> : リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-nc <var>num</var></code> : 非リーフノード用キャッシュの最大数を指定する。</li>
<li><code>-ls <var>num</var></code> : リーフノードの最大サイズを指定する。</li>
<li><code>-nl</code> : オプション `BDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `BDBLCKNB' を有効にする。</li>
<li><code>-wb</code> : 関数 `tcbdbget' の代わりに関数 `tcbdbget3' を用いる。</li>
<li><code>-pn <var>num</var></code> : パターン数を指定する。</li>
<li><code>-rl</code> : 値を無作為な長さにする。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcbmttest</code>' は、B+木データベースAPIの機能テストをマルチスレッドで行うツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>rnum</var>' は試行回数を指定し、`<var>lmemb</var>' はリーフ内メンバ数を指定し、`<var>nmemb</var>' は非リーフ内メンバ数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定します。</p>

<dl class="api">
<dt><code>tcbmttest write [-tl] [-td|-tb] [-nl|-nb] [-rnd] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcbmttest read [-nl|-nb] [-wb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcbmttest remove [-nl|-nb] [-rnd] <var>path</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcbmttest wicked [-tl] [-td|-tb] [-nl|-nb] [-nc] <var>path</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
<dt><code>tcbmttest typical [-tl] [-td|-tb] [-nl|-nb] [-nc] [-rr <var>num</var>] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>典型的な操作を無作為に選択して実行する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-tl</code> : オプション `BDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `BDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `BDBTTCBS' を有効にする。</li>
<li><code>-nl</code> : オプション `BDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `BDBLCKNB' を有効にする。</li>
<li><code>-rnd</code> : キーを無作為に選択する。</li>
<li><code>-wb</code> : 関数 `tcbdbget' の代わりに関数 `tcbdbget3' を用いる。</li>
<li><code>-nc</code> : 比較テストを行わない。</li>
<li><code>-rr <var>num</var></code> : 読み込み操作の割合を百分率で指定する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcbmgr</code>' は、B+木データベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>path</var>' はデータベースファイルのパスを指定し、`<var>lmemb</var>' はリーフ内メンバ数を指定し、`<var>nmemb</var>' は非リーフ内メンバ数を指定し、`<var>bnum</var>' はバケット数を指定し、`<var>apow</var>' はアラインメント力を指定し、`<var>fpow</var>' はフリーブロックプール力を指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定し、`<var>file</var>' は入力ファイルを指定します。</p>

<dl class="api">
<dt><code>tcbmgr create [-cd|-ci|-cj] [-tl] [-td|-tb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースファイルを作成する。</dd>
<dt><code>tcbmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tcbmgr put [-cd|-ci|-cj] [-nl|-nb] [-sx] [-dk|-dc] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tcbmgr out [-cd|-ci|-cj] [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tcbmgr get [-cd|-ci|-cj] [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tcbmgr list [-cd|-ci|-cj] [-nl|-nb] [-m <var>num</var>] [-bk] [-pv] [-px] [-j <var>str</var>] [-rb <var>bkey</var> <var>ekey</var>] [-rp <var>str</var>] <var>path</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tcbmgr optimize [-cd|-ci|-cj] [-tl] [-td|-tb] [-tz] [-nl|-nb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>データベースを最適化する。</dd>
<dt><code>tcbmgr importtsv [-nl|-nb] [-sc] <var>path</var> [<var>file</var>]</code></dt>
<dd>TSVファイルの各行をキーと値とみなしてレコードを登録する。</dd>
<dt><code>tcbmgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-cd</code> : 比較関数 `tcbdbcmpdecimal' を利用する。</li>
<li><code>-ci</code> : 比較関数 `tcbdbcmpint32' を利用する。</li>
<li><code>-cj</code> : 比較関数 `tcbdbcmpint64' を利用する。</li>
<li><code>-tl</code> : オプション `BDBTLARGE' を有効にする。</li>
<li><code>-td</code> : オプション `BDBTDEFLATE' を有効にする。</li>
<li><code>-tb</code> : オプション `BDBTTCBS' を有効にする。</li>
<li><code>-nl</code> : オプション `BDBNOLCK' を有効にする。</li>
<li><code>-nb</code> : オプション `BDBLCKNB' を有効にする。</li>
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tchdbput' の代わりに関数 `tchdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tchdbput' の代わりに関数 `tchdbputcat' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-bk</code> : 走査を逆方向で行う。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
<li><code>-j <var>str</var></code> : カーソルを指定位置にジャンプさせる。</li>
<li><code>-rb <var>bkey</var> <var>ekey</var></code> : 処理対象を範囲指定する。</li>
<li><code>-rp <var>pkey</var></code> : 処理対象を前方一致指定する。</li>
<li><code>-tz</code> : オプション `UINT8_MAX' を有効にする。</li>
<li><code>-sc</code> : キーを小文字に正規化する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tcadbapi">抽象データベースAPI</h2>

<p>抽象データベースは、オンメモリデータベースとハッシュデータベースとB+木データベースを同一のAPIで抽象化したデータベースです。それを扱うのが抽象データベースAPIです。`<code>tcadb.h</code>' にAPIの仕様の完全な記述があります。</p>

<h3>概要</h3>

<p>抽象データベースAPIを使うためには、`<code>tcutil.h</code>'、`<code>tcadb.h</code>' および関連する標準ヘッダファイルをインクルードしてください。通常、ソースファイルの冒頭付近で以下の記述を行います。</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tcadb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>抽象データベースを扱う際には、`<code>TCADB</code>' 型へのポインタをオブジェクトとして用います。B+木データベースオブジェクトは、関数 `<code>tcadbnew</code>' で作成し、関数 `<code>tcadbdel</code>' で破棄します。作成したオブジェクトを使い終わったら必ず破棄してください。そうしないとメモリリークが発生します。</p>

<p>レコードの格納や探索を行う前提として、抽象データベースオブジェクトを具象データベースと接続させる必要があります。具象データベースを開いて接続するには関数 `<code>tcadbopen</code>' を用い、接続の解除してファイルを閉じるには関数 `<code>tcadbclose</code>' を用います。開いた具象データベースは必ず閉じてください。そうしないと具象データベースが壊れたり格納したデータが失われたりする可能性があります。</p>

<h3>API（英語ごめんね）</h3>

<p>The function `tcadbnew' is used in order to create an abstract database object.</p>

<dl class="api">
<dt><code>TCADB *tcadbnew(void);</code></dt>
<dd>The return value is the new abstract database object.</dd>
</dl>

<p>The function `tcadbdel' is used in order to delete an abstract database object.</p>

<dl class="api">
<dt><code>void tcadbdel(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
</dl>

<p>The function `tcadbopen' is used in order to open an abstract database.</p>

<dl class="api">
<dt><code>bool tcadbopen(TCADB *<var>adb</var>, const char *<var>name</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>name</var>' specifies the name of the database.  If it is "*", the database will be an on-memory database.  If its suffix is ".tch", the database will be a hash database.  If its suffix is ".tcb", the database will be a B+ tree database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by "#".  Each parameter is composed of the name and the number, separated by "=".  On-memory database supports "bnum", "capnum", and "capsiz".  Hash database supports "mode", "bnum", "apow", "fpow", "opts", and "rcnum".  B+ tree database supports "mode", "lmemb", "nmemb", "bnum", "apow", "fpow", "opts", "lcnum", and "ncnum".  "capnum" specifies the capacity number of records.  "capsiz" specifies the capacity size of using memory.  Records spilled the capacity are removed by the storing order.  "mode" should be "w" of writer or "r" of reader.  The default is writer.  "opts" can contains "l" of large option, "d" of Deflate option, and "b" of TCBS option.  For example, "casket.tch#bnum=1000000#opts=ld" means that the name of the database file is "casket.tch", and the bucket number is 1000000, and the options are large and Deflate.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbclose' is used in order to close an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbclose(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcadbput' is used in order to store a record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbput(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcadbput2' is used in order to store a string record into an abstract object.</p>

<dl class="api">
<dt><code>bool tcadbput2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcadbputkeep' is used in order to store a new record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputkeep(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcadbputkeep2' is used in order to store a new string record into an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputkeep2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcadbputcat' is used in order to concatenate a value at the end of the existing record in an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputcat(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcadbputcat2' is used in order to concatenate a string value at the end of the existing record in an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbputcat2(TCADB *<var>adb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcadbout' is used in order to remove a record of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbout(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbout2' is used in order to remove a string record of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbout2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbget' is used in order to retrieve a record in an abstract database object.</p>

<dl class="api">
<dt><code>void *tcadbget(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcadbget2' is used in order to retrieve a string record in an abstract database object.</p>

<dl class="api">
<dt><code>char *tcadbget2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcadbvsiz' is used in order to get the size of the value of a record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbvsiz(TCADB *<var>adb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcadbvsiz2' is used in order to get the size of the value of a string record in an abstract database object.</p>

<dl class="api">
<dt><code>int tcadbvsiz2(TCADB *<var>adb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tcadbiterinit' is used in order to initialize the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbiterinit(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tcadbiternext' is used in order to get the next key of the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>void *tcadbiternext(TCADB *<var>adb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tcadbiternext2' is used in order to get the next key string of the iterator of an abstract database object.</p>

<dl class="api">
<dt><code>char *tcadbiternext2(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tcadbsync' is used in order to synchronize updated contents of an abstract database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcadbsync(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function fails and has no effect for on-memory database.</dd>
</dl>

<p>The function `tcadbvanish' is used in order to remove all records of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbvanish(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcadbcopy' is used in order to copy the database file of an abstract database object.</p>

<dl class="api">
<dt><code>bool tcadbcopy(TCADB *<var>adb</var>, const char *<var>path</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>`<var>path</var>' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if the executed command returns non-zero code.</dd>
<dd>The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.  This function fails and has no effect for on-memory database.</dd>
</dl>

<p>The function `tcadbrnum' is used in order to get the number of records of an abstract database object.</p>

<dl class="api">
<dt><code>uint64_t tcadbrnum(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database instance.</dd>
</dl>

<p>The function `tcadbsize' is used in order to get the size of the database of an abstract database object.</p>

<dl class="api">
<dt><code>uint64_t tcadbsize(TCADB *<var>adb</var>);</code></dt>
<dd>`<var>adb</var>' specifies the abstract database object.</dd>
<dd>The return value is the size of the database or 0 if the object does not connect to any database instance.</dd>
</dl>

<h3>コード例</h3>

<p>抽象データベースを使ったコード例を以下に示します。</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tcadb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){

  TCADB *adb;
  char *key, *value;

  /* create the object */
  adb = tcadbnew();

  /* open the database */
  if(!tcadbopen(adb, "casket.tch")){
    fprintf(stderr, "open error\n");
  }

  /* store records */
  if(!tcadbput2(adb, "foo", "hop") ||
     !tcadbput2(adb, "bar", "step") ||
     !tcadbput2(adb, "baz", "jump")){
    fprintf(stderr, "put error\n");
  }

  /* retrieve records */
  value = tcadbget2(adb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    fprintf(stderr, "get error\n");
  }

  /* traverse records */
  tcadbiterinit(adb);
  while((key = tcadbiternext2(adb)) != NULL){
    value = tcadbget2(adb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* close the database */
  if(!tcadbclose(adb)){
    fprintf(stderr, "close error\n");
  }

  /* delete the object */
  tcadbdel(adb);

  return 0;
}
</pre>

<h3>CLI</h3>

<p>抽象データベースAPIを簡単に利用するために、コマンドラインインターフェイスとして `<code>tcatest</code>' と `<code>tcamgr</code>' が提供されます。</p>

<p>コマンド `<code>tcatest</code>' は、抽象データベースAPIの機能テストや性能テストに用いるツールです。以下の書式で用います。`<var>name</var>' はデータベースの名前を指定し、`<var>rnum</var>' は試行回数を指定します。</p>

<dl class="api">
<dt><code>tcatest write <var>name</var> <var>rnum</var></code></dt>
<dd>`00000001'、`00000002' のように変化する8バイトのキーと値を連続してデータベースに追加する。</dd>
<dt><code>tcatest read <var>name</var></code></dt>
<dd>上記で生成したデータベースの全レコードを検索する。</dd>
<dt><code>tcatest remove <var>name</var></code></dt>
<dd>上記で生成したデータベースの全レコードを削除する。</dd>
<dt><code>tcatest rcat <var>name</var> <var>rnum</var></code></dt>
<dd>キーがある程度重複するようにレコードの追加を行い、連結モードで処理する。</dd>
<dt><code>tcatest misc <var>name</var> <var>rnum</var></code></dt>
<dd>各種操作の組み合わせテストを行う。</dd>
<dt><code>tcatest wicked <var>name</var> <var>rnum</var></code></dt>
<dd>各種更新操作を無作為に選択して実行する。</dd>
</dl>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<p>コマンド `<code>tcamgr</code>' は、抽象データベースAPIやそのアプリケーションのテストやデバッグに役立つツールです。以下の書式で用います。`<var>name</var>' はデータベースの名前を指定し、`<var>key</var>' はレコードのキーを指定し、`<var>value</var>' はレコードの値を指定します。</p>

<dl class="api">
<dt><code>tcamgr create <var>name</var></code></dt>
<dd>データベースを作成する。</dd>
<dt><code>tcamgr inform <var>name</var></code></dt>
<dd>データベースの雑多な情報を出力する。</dd>
<dt><code>tcamgr put [-sx] [-dk|-dc] <var>name</var> <var>key</var> <var>value</var></code></dt>
<dd>レコードを追加する。</dd>
<dt><code>tcamgr out [-sx] <var>name</var> <var>key</var></code></dt>
<dd>レコードを削除する。</dd>
<dt><code>tcamgr get [-sx] [-px] [-pz] <var>name</var> <var>key</var></code></dt>
<dd>レコードの値を取得して標準出力する。</dd>
<dt><code>tcamgr list [-m <var>num</var>] [-pv] [-px] <var>name</var></code></dt>
<dd>全てのレコードのキーを改行で区切って標準出力する。</dd>
<dt><code>tcamgr version</code></dt>
<dd>Tokyo Cabinetのバージョン情報を標準出力する。</dd>
</dl>

<p>各オプションは以下の機能を持ちます</p>

<ul class="options">
<li><code>-sx</code> : 入力を16進数の文字列で行う。</li>
<li><code>-dk</code> : 関数 `tchdbput' の代わりに関数 `tchdbputkeep' を用いる。</li>
<li><code>-dc</code> : 関数 `tchdbput' の代わりに関数 `tchdbputcat' を用いる。</li>
<li><code>-px</code> : 出力を16進数の文字列で行う。</li>
<li><code>-pz</code> : 出力の末尾に改行を付加しない。</li>
<li><code>-m <var>num</var></code> : 出力の最大数を指定する。</li>
<li><code>-pv</code> : レコードの値も出力する。</li>
</ul>

<p>このコマンドは処理が正常に終了すれば 0 を返し、エラーがあればそれ以外の値を返して終了します。</p>

<hr />

<h2 id="tips">ちょっとしたコツ</h2>

<p>この節ではTokyo Cabinetの使い方のコツや知っておくと便利な小技を紹介します。</p>

<h3>ユーティリティAPI</h3>

<p>C++、Perl、Ruby、Javaといった高水準な言語では必ずといってリストやマップといったデータ構造を簡単に利用できる機能が標準ライブラリとしてついてきます。しかし、C言語にはそれに相当するものはありません。GNOME GlibやApache APRなどの非標準ライブラリを使うのも一興ですが、Tokyo Cabinetにも高機能・高性能なユーティリティが付属しています。STL（C++の標準テンプレートライブラリ）のstringにあたるものがTCXSTRで、listにあたるものがTCLISTで、mapやsetにあたるものがTCMAPです。他にも文字列処理や各種符号処理のユーティリティも提供されます。それらを使いこなすとC言語でもC++やその他の高水準言語並みの直感的なプログラミングができるでしょう。</p>

<p>TCXSTRの何が便利かと言えば、`<code>tcxstrcat</code>' です。特にバッファリングに有用で、後ろにデータをどんどんくっつけていけるのです。メモリ領域は内部で適宜拡張してくれるので、アプリケーション側でメモリ管理に悩む必要はありませんし、性能もかなり良いです。</p>

<p>TCLISTは配列で実装されたリストです。これはスタック（`<code>tclistpush</code>' で格納して `<code>tclistpop</code>' で取り出す）としてもキュー（`<code>tclistpush</code>' で格納して `<code>tclistshift</code>' で取り出す）としても使えます。もちろんメモリ管理は内部でよろしくやってくれますし、性能もかなり良いです。</p>

<p>TCMAPはハッシュマップの実装です。任意のキーに対応づけて任意の値を格納できます。DBMのオンメモリ版と考えてもよいでしょう。TCMAPのイテレータはレコードを格納した順番に取り出すことができるというのが特徴で、かつ任意のレコードを先頭や末尾に移動させることもできるので、LRU消去方式のキャッシュとしても利用することができます。もちろんメモリ管理は内部でよろしくやってくれますし、性能もかなり良いです。</p>

<p>TCXSTRとTCLISTとTCMAPの各関数はリエントラントですが、該当のオブジェクトを複数のスレッドで共有する場合にはアプリケーション側で排他制御を行うことが求められます。ただし、ハッシュマップに関しては排他制御を内部で行う実装としてTCMDBが提供されます。</p>

<p>TCMPOOLというのもあります。これはいわゆるメモリプールの実装で、メモリ管理の単位を一括して楽をすることができる機能です。例えば `<code>malloc</code> で確保した領域は必ず `<code>free</code>' で解放しないとメモリリークになってしまいますが、`<code>tcmpoolmalloc</code>' で確保した領域は明示的に解放しないでよいのです。ではいつ解放されるのかと言えば、メモリプール自体を解放した時です。つまりアプリケーション側ではメモリプールの寿命にだけ気を付ければよく、個々のオブジェクトの寿命を気にしなくてもよくなるということです。メモリプールはTCXSTRやTCLISTやTCMAPのオブジェクトを発生させることもできますし、任意のオブジェクトをデストラクタとともに登録することもできます。典型的には以下のような使い方をします。</p>

<pre>TCMPOOL *mpool;
int i, j;
char *buf;
for(i = 0; i &lt; 100; i++){
  mpool = tcmpoolnew();
  for(j = 0; j &lt; 100; ++){
    buf = tcmpoolmalloc(10); // メモリプール内オブジェクトの生成
    ...                      // いちいち解放しなくてOK
  }
  tcmpooldel(mpool);         // ここで一気に解放
}
</pre>

<h3>ハッシュデータベースのチューニング</h3>

<p>チューニングをするかしないかでデータベース操作の性能は劇的に変わるので、まじめなユースケースでは、チューニングは必須となるでしょう。関数 `<code>tchdbtune</code>' でそれを行います。この関数では「バケット数」と「アラインメント力」と「フリーブロックプール力」と「オプション」が指定されます。</p>

<p>最も重要なのは、バケット数の設定です。これは、データベースに格納するレコードの最終的な数の数倍（2〜4倍程度がオススメ）を指定すべきです。デフォルトは16381なので、10000個以上のレコードを入れるならばまずこれを設定すべきです。例えば100万レコードくらいを入れる予定ならば、バケット数は200万〜400万くらいにしておくとよいでしょう。バケット配列の個々の要素のサイズは4バイト（32ビット）なので、バケット数を200万にした場合にはファイルサイズが8MB増えて、メモリも8MB必要となるわけですが、21世紀のコンピュータならそれくらい大したことないでしょう。とりあえずバケット数は大きめにとりましょう。</p>

<p>アラインメントは、レコードの開始位置を揃える機構です。指定したアラインメント力で1を高位にビットシフトした数に開始アドレスが揃えられます。デフォルトは4です。例えばアラインメント力を8にしたならば、1&lt;&lt;8で、256の倍数に開始位置が揃えられます。アラインメントの利点は三つあります。一つめは、開始アドレスを揃えることでレコード間にパディング（隙間）ができることです。レコードサイズの増減がパディングの範囲に収まれば、更新時にレコードの位置を変えなくてもよくなります。二つめは、レコードの読み書きをファイルシステムのブロック単位にあわせて行うことができるために、OSレベルでのI/Oの処理が効率化されることです。三つめは、開始アドレスをアラインメントの商として記録できるようになるため、4バイトのバケットで表せる変域が増加することです。アラインメントを用いない場合は2GB（1&lt;&lt;31）までのデータベースファイルしか扱えませんが、例えばアラインメントが256であれば、2GB*256で512GBまでのデータベースファイルを扱うことができます。</p>

<p>フリーブロックとは、更新によってできたファイル内の未使用領域のことです。フリーブロックプールはそれを管理して再利用する機構です。指定したフリーブロックプール力で1を高位にビットシフトした数がフリーブロックプールの容量になります。デフォルトは10です。この設定を変える必要はほとんどないでしょう。</p>

<p>オプションとは、レコードの格納方法を指定するフラグの集合のことです。`<code>HDBTLARGE</code>' と `<code>HDBTDEFLATE</code>' と `<code>HDBTTCBS</code>' の論理和で指定します。`<code>HDBTLARGE</code>' を指定すると、バケットの個々の要素を8バイト（64ビット）で扱います。バケット配列のサイズが2倍になるかわりに、データベースのサイズの上限を8EBに引き上げます。`<code>HDBTDEFLATE</code>' を指定すると、レコードをDeflateアルゴリズムで圧縮してから記録します。大きいサイズ（256バイト以上）のレコードを格納する場合に有利です。`<code>HDBTTCBS</code>' を指定すると、レコードをBWT、MTF、Elias Gamma符号で圧縮してから記録します。小さいサイズ（256バイト未満）のレコードを格納する場合に有利です。</p>

<p>チューニングパラメータの設定はデータベースを作成する前に行う必要があります。チューニングパラメータはメタデータとしてデータベース内に記録されるので、作成した後は指定する必要はありません。なお、いったん作成したデータベースのチューニングを変更することはできません（最適化すればできますが）。バケット数を1000000、アラインメント数を12（4096）、フリーブロックをデフォルト、オプションを `<code>HDBTLARGE</code>' と `<code>HDBTDEFLATE</code>' に指定してデータベースを作成する場合、以下のようなコードになります。</p>

<pre>TCHDB *hdb;
hdb = tchdbnew();
tchdbtune(hdb, 1000000, 12, -1, HDBTLARGE | HDBTDEFLATE);
tchdbopen(hdb, "casket.hdb", HDBOWRITER | HDBOCREAT);
...
</pre>

<p>ハッシュデータベースはキャッシュ機構を備えます。これは一旦検索されたレコードをメモリ上に保持しておくもので、同一のレコードが何度も検索される場合の性能を向上させてくれます。キャッシュ上にあるレコードが更新された場合、そのレコードはキャッシュから削除されますので、検索の頻度よりも更新の頻度が多い場合にはあまり効果はありません。また、キャッシュを有効にするとキャッシュを管理するためのオーバーヘッドがかかるので、キャッシュのヒット率がある程度以上でないと逆に処理が遅くなってしまいます。したがって、キャッシュのヒット率がかなり高い場合（つまり同じレコードを何度も参照するような場合）にのみキャッシュ機構を利用すべきです。ハッシュデータベースのキャッシュはデフォルトでは無効になっていますので、有効にする場合は関数 `<code>tchdbsetcache</code>' で設定してください。キャッシュパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回設定する必要があります。</p>

<h3>B+木データベースのチューニング</h3>

<p>チューニングをするかしないかで性能が劇的に変わるのはB+木データベースについても同じです。まじめなユースケースではちゃんとチューニングしましょう。チューニングは関数 `<code>tcbdbtune</code>' で行います。この関数では「リーフ内メンバ数」「非リーフ内メンバ数」「バケット数」と「アラインメント力」と「フリーブロックプール力」と「オプション」が指定されます。</p>

<p>リーフまたはリーフページとは、B+木の末端のノードのことで、複数のレコードのキーと値のリストが格納される記憶単位のことです。リーフ内メンバ数とは、ひとつのリーフの中にいくつのレコードを格納するかの設定です。デフォルトは128です。比較関数の順序通りにレコードを格納または探索することが多い場合はこの値を大きくした方が性能がよくなり、逆に比較関数の順序とは無関係にレコードを格納または探索することが多い場合は小さくした方がよくなります。非リーフまたは非リーフページとはB+木の末端以外のノードのことで、複数のレコードのキーのみが格納される記憶単位のことです。非リーフの数はリーフに比べて少なく、性能に与える影響はあまり大きくありません。非リーフ内メンバ数をデフォルトから変える必要はほとんどないでしょう。</p>

<p>バケット数やその他のパラメータ、B+木データベースの下層にあるハッシュデータベースにそのまま渡されます。B+木の各ページはハッシュデータベースのレコードとして記録されるので、バケット数などのパラメータはその際に意味を持ちます。したがって、ここで指定するバケット数は、B+木データベースにおける最終的なレコード数をリーフ内メンバ数で割った値の数倍に設定するのが最善です。とはいえB+木データベースにおいてはバケット数などのパラメータを変更する必要はあまりないでしょう。</p>

<p>チューニングの例として、平均8バイトのキーと平均32バイトの値のレコードを100万件格納することを考えてみます。各コードのヘッダなどのオーバーヘッドは5バイト程度です。ファイルシステムのブロックサイズは4096バイトとします。すると、1ブロックに入れられるレコード数は4096/(8+32+5)で90個ほどということになります。さらに、Deflate圧縮オプションを有効にして、その圧縮率が50%ほどだとしましょう。となると180個ほどのレコードが1ブロックに収まることが期待されます。各リーフのサイズは2ブロックか3ブロックのサイズが望ましいので、180を2倍した360がリーフ内メンバ数の理想値になります。となると、バケット数は1000000/360で2777となり、デフォルトの16381から変える必要はないでしょう。アラインメント力はファイルシステムのブロックサイズにあわせるためにlog2(4096)で12にします。以上の設定をコードに反映すると以下のようになります。</p>

<pre>TCHDB *bdb;
bdb = tcbdbnew();
tcbdbtune(hdb, 360, -1, -1, 12, -1, BDBTDEFLATE);
tcbdbopen(hdb, "casket.bdb", BDBOWRITER | BDBOCREAT);
...
</pre>

<p>B+木データベースもキャッシュ機構を備えます。これは処理対象のページをメモリ上に保持しておくもので、同一のページが何度も読み書きされる場合の性能を向上させてくれます。キャッシュ上にあるページが更新された場合でも、そのページはメモリ上に保持されたままなので、検索も更新も高速化されます。B+木データベースのキャッシュはデフォルトでは小さめに設定されていますので、メモリを多く使っても高速化したい場合は関数 `<code>tcbdbsetcache</code>' で設定してください。キャッシュパラメータの設定はデータベースに接続する前に行う必要があり、また接続する度に毎回設定する必要があります。</p>

<h3>マルチスレッド対応</h3>

<p>Tokyo CabinetのAPIにおける各関数はリエントラントなので、引数として与えるデータが各スレッドで別々のものであれば完全に並列に操作を実行することができます。しかし、データベースオブジェクトは内部状態を持つので、ひとつのデータベースオブジェクトを複数のスレッドで共有する場合には、更新操作に関連して排他制御を行う必要があります。とはいえ、特に難しいことはありません。複数のスレッドで共有するデータベースオブジェクトに対して、作成した直後に関数 `<code>tchdbsetmutex</code>' や `<code>tcbdbsetmutex</code>' を呼び出すだけでOKです。そうすると以後の操作の内部で適切にロックを用いて排他制御が行われるようになります。複数のスレッドを使うが各々が別個のデータベースオブジェクトにアクセスする場合には排他制御は必要ありませんし、排他制御をしない方が高速に動作します。</p>

<p>スレッド間の排他制御はリードライトロックで行われます。`open'、`close'、`put'、`out' などの操作にはライトロック（排他ロック）がかけられ、`get'、`curkey'、`curval' などの操作にはリードロック（共有ロック）がかけられます。つまり、読み込みは激しく同時に行えますが、書き込みをしている間は他のスレッドはブロックされるということです。データベースオブジェクトの排他制御の設定はデータベースに接続する前に行う必要があり、また接続する度に毎回行う必要があります。以下のようなコードになります。</p>

<pre>TCHDB *hdb;
hdb = tchdbnew();
tchdbsetmutex(hdb);
tchdbopen(hdb, "casket.hdb", HDBOWRITER);
...
</pre>

<h3>トランザクション</h3>

<p>B+木データベースにはトランザクション機構があります。トランザクションを開始してから行った一連の操作は、コミットすることで確定させたり、アボートすることでなかったことにしたりすることができます。トランザクション中にアプリケーションがクラッシュ場合にも、トランザクション中の操作がなかったことになるだけで、データベースの整合性は維持されます。トランザクションは以下のようなコードで用います。</p>

<pre>tcbdbtranbegin(hdb);
do_something();
if(is_all_ok){
  tcbdbtrancommit(hdb);
} else {
  tcbdbtranabort(hdb);
}
</pre>

<p>トランザクションを実行できるのは同時1スレッドのみで、他のスレッドはその間ブロックされます。したがって、データベースの参照をトランザクション内でのみ行うならば、トランザクションの分離レベルは直列化可能（serializable）になります。しかし、あるスレッドがトランザクションの最中でも他のスレッドはトランザクションを実行せずにデータベースを参照できます。その場合の分離レベルは非コミット読み取り（read uncommitted）になります。状況に応じて使い分けてください。</p>

<h3>カーソル</h3>

<p>B+木データベースにはカーソル機構があります。カーソルは指定したキーの場所にジャンプさせることができ、そこから前後にひとつずつずらしながらレコードを参照したり更新したりすることができます。例えば文字列の前方一致検索を行う場合、接頭辞をキーとして指定してカーソルをジャンプさせて、そこから前に進みながらキーを一つ一つ参照していって、前方一致しなかった時点で止めるという処理になります。例えば "tokyo" で始まるキーのレコードを取り出すには以下のようなコードになるでしょう。</p>

<pre>cur = tcbdbcurnew();
tcbdbcurjump2(cur, "tokyo");
while((key = tcbdbcurkey2(cur)) != NULL){
  if(!tcstrfwm(kbuf, "tokyo")){
    free(key);
    break;
  }
  if((val = tcbdbcurval2(cur)) != NULL){
    do_something(key, val);
    free(val);
  }
  free(key);
  tcbdbcurnext();
}
tcbdbcurdel(cur);
</pre>

<p>カーソルをジャンプさせてから、他のスレッドが同一のデータベースに対して更新を行った場合、そのカーソルの位置はずれる可能性があります。具体的には、カーソルのあるリーフ上でカーソルより前にレコード挿入された場合、カーソルは小さい方向にひとつずれます。また、カーソルのあるリーフ上でカーソルより前にあるレコードが削除された場合、カーソルは大きい方向にひとつずれます。したがって、検索などの非クリティカルな操作では特別な配慮は必要ありませんが、更新にカーソルを使う場合には、処理中にカーソルの位置がずれないようにトランザクションを使うか、アプリケーション側の責任で排他制御をすることになるでしょう。なお、典型的な検索操作である範囲検索をアトミックに行うために関数 `<code>tcbdbrange</code>' および関数 `<code>tcbdbrangefwm</code>' が提供されています。</p>

<h3>バックアップ</h3>

<p>データベースファイルのバックアップは、通常のファイルと同様に<code>cp</code>や<code>tar</code>や<code>cpio</code>といったコマンドで行うことができます。ただし、ライタとして接続しているプロセスがデータベースを更新中である場合、コピー元のファイルの状態が中途半端になっている可能性があるため、コピー先のファイルに不整合が起きる場合があります。したがって、データベースが更新中でないこと確認してからバックアップ作業を行うことが必要となります。</p>

<p>デーモンプロセスなどの常駐プロセスがデータベースに接続し続けるユースケースでは上記の手順は現実的ではありません。そういった場合、その常駐プロセスの責任でバックアップ処理を駆動することができます。関数 `<code>tchdbcopy</code>' や `<code>tcbdbcopy</code>' を呼び出すと、更新内容をデータベースファイルと同期させた上で、その間にファイルの複製を行います。</p>

<p>バックアップ用関数は任意のコマンドを呼び出すこともできます。コピー先のファイル名の代わりに "@" で始まるコマンド名を指定するとそれが呼び出されます。そのコマンドの第1引数にはデータベース名が指定され、第2引数には現在のUNIX時間のマイクロ秒が指定されます。例えば、以下のようなシェルスクリプトを用意してそれを呼び出すようにするとよいでしょう。</p>

<pre>#! /bin/sh
srcpath="$1"
destpath="$1.$2"
rm -f "$destpath"
cp -f "$srcpath" "$destpath"
</pre>

<p>バックアップ用のコマンドを実行している間はそのデータベースの更新はブロックしますので、コピーに時間がかかる場合には留意が必要です。無停止のホットバックアップを望むならば、"cp" などによる単純なファイル複製の代わりにファイルシステム（LVM）のスナップショット機能を使うとよいでしょう。</p>

<h3>ハッシュデータベースとB+木データベースの比較</h3>

<p>キーと値のペアを格納したいというのははっきりしているが、ハッシュデータベースとB+木データベースのどちらを使えばよいかわからないという場合もあるかもしれません。その場合、レコードの検索条件が完全一致だけで済むのなら、ハッシュデータベースを試してください。レコードを順序に基づいて参照したいなら、B+木データベースを試してください。メモリ上だけ保持してファイルに書き出す必要がないならば、ユーティリティAPIのハッシュマップを試してください。</p>

<p>検索条件が完全一致の場合にはハッシュデータベースを使うのが一般的ですが、B+木でも完全一致検索はできます。ファイルシステムのI/Oキャッシュに乗らない大規模のデータベースでは、ハッシュデータベースとB+木データベースの性能特性を考えて、使うデータベースの種類を選択することが重要です。</p>

<p>ハッシュデータベースのキャッシュ機構はレコード単位ですが、B+木データベースはキャッシュ機構はページ単位であるというのが性能上の最大の留意点です。B+木データベースにおいては、データベース内の全てのレコードはキーの昇順で並べられ、順番が近いレコードをページにまとめて管理します。キャッシュやI/Oはページを単位として行います。したがって、順番が近いレコードを参照する場合にはキャッシュがヒットしてI/Oを伴わずに操作が完結するので効率がよくなります。ということは、多数のレコードを格納する際に、対象のレコード群をキーの昇順でソートしてからデータベースに格納すると、I/Oの回数が最小化されて時間効率も空間効率も最高になります。これはアプリケーション層でもキャッシュ機構を持つことを要求するものですが、至高を求めるあなたには不可能ではないはずです。全文検索システムHyper Estraierのインデクシングが高速な秘訣はまさにここにあります。</p>

<p>逆に考えれば、データベースにアクセスする順序が制御できない場合は、B+木データベースよりもハッシュデータベースを使う方が有利ということになります。キャッシュに乗らない場合には、ハッシュデータベースの方がメモリ使用量も小さく、個々のレコードを取り出す際の計算量も小くて済みます。なお、ハッシュデータベースの構築時に一気にレコードを入れるような用途の場合には、非同期モードを使うとB+木データベース以上の更新性能を実現できます。新しいレコードはファイルの末尾に記録されることを利用して、ファイルの末尾部分に特化したキャッシュを作ることができるからです。</p>

<h3>抽象データベース</h3>

<p>ハッシュデーターベースかB+木データベースかを実行時に決定したい場合には、抽象データベースAPIを使うとよいでしょう。抽象データベースAPIはオンメモリデータベースAPIとハッシュデータベースAPIとB+木データベースAPIの共通のインターフェイスで、関数 `<code>tcadbopen</code>' でデータベースを開く際のデータベース名で具体的にどの種類のデータベースを扱うかを指定することができます。ハッシュデータベースの名前には接尾辞として ".tch" をつけ、B+木データベースの名前には接尾辞として ".tcb" をつけることで区別されます。チューニングパラメータは、名前の後に "#" で区切って "name=value" の形式で指定します。例えば "casket.tch#bnum=1000000#apow=10" などとします。</p>

<p>抽象データベースAPIはオンメモリデータベースとしても利用することができます。データベース名を "*" とするとオンメモリデータベースになります。また、オンメモリデータベースをキャッシュとして利用したい場合は、"*#capsiz=104857600" などとするとよいでしょう。キャッシュの容量を100MBに限定して、それを越えた際には格納した順序が古いレコードから自動的に消していくようになります。</p>

<h3>リモートインターフェイス</h3>

<p>多種のアプリケーションでデータベースを共有したい場合やWebアプリケーション等でマルチプロセスの並列処理を行う場合は、Tokyo Cabinetのファイルロック機構が鬱陶しく感じるかもしれません。また、複数のマシンからデータベースを参照したい場合にはTokyo Cabinetだと困ってしまうかもしれません。</p>

<p>データベースの管理のみを行うサーバを別プロセスとして立ちあげて、アプリケーションのプロセスがネットワークソケットを介してそのサーバに接続すれば上記の問題は解決します。そのようなデータベースサーバとそれに接続するためのライブラリが別パッケージ「Tokyo Tyrant」として提供されています。Tokyo Tyrantのサーバは抽象データベースを扱うので、オンメモリデータベースでもハッシュデータベースでもB+木データベースでもリモートインターフェイスで操作することができます。</p>

<h3>C言語以外の言語のバインディング</h3>

<p>PerlとRubyとJavaの言語バインディングに関しては、Tokyo Cabinetの作者が開発およびメンテナンスを行います。それ以外の言語に関しては、第三者が提供してくれることを望みます。</p>

<p>ユーザの利便性を考えると、C言語以外の言語においても、APIのシンボル名や使い方はできるだけ似通ったものにすることが望ましいでしょう。そのために、`<code>tokyocabinet.idl</code>' が提供されます。これはIDLで言語共通のインターフェイスを定義したものですので、新たな言語バインディングを設計する際には、できるだけそれに準拠するようにしてください。IDLで定義されていない機能は各言語の流儀にできるだけ合わせてください。インストールの手順やドキュメントなどのパッケージの構造についても、各言語の流儀にできるだけ合わせるとよいでしょう。</p>

<hr />

<h2 id="fileformat">ファイルフォーマット</h2>

<p>この節ではデータベースファイルのフォーマットに関する仕様を示します。</p>

<h3>ハッシュデータベースのファイルフォーマット</h3>

<p>ハッシュデータベースが管理するデータベースファイルの内容は、ヘッダ部、バケット部、フリーブロックプール部、レコード部の4つに大別されます。ファイルに記録される数値は固定長数値もしくは可変長数値として記録されます。前者は数値を特定の領域にリトルエンディアンで直列化したものです。後者は数値を可変長の領域に128進法のデルタ符号で直列化したものです。</p>

<p>ヘッダ部はファイルの先頭から256バイトの固定長でとられ、以下の情報が記録されます。</p>

<table summary="database header format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">32</td>
<td>データベースファイルであることの判別。「ToKyO CaBiNeT」で始まる</td>
</tr>
<tr>
<td>データベースタイプ</td>
<td class="number">32</td>
<td class="number">1</td>
<td>ハッシュ表（0x10）かB+木（0x20）</td>
</tr>
<tr>
<td>追加フラグ</td>
<td class="number">33</td>
<td class="number">1</td>
<td>開きっぱなし（1&lt;&lt;0）、致命的エラー（1&lt;&lt;1）の論理和</td>
</tr>
<tr>
<td>アラインメント力</td>
<td class="number">34</td>
<td class="number">1</td>
<td>アラインメントに対する2の冪乗</td>
</tr>
<tr>
<td>フリーブロックプール力</td>
<td class="number">35</td>
<td class="number">1</td>
<td>フリーブロックプールの要素数に対する2の冪乗</td>
</tr>
<tr>
<td>オプション</td>
<td class="number">36</td>
<td class="number">1</td>
<td>ラージモード（1&lt;&lt;0）、Deflate圧縮モード（1&lt;&lt;1）、TCBS圧縮モード（1&lt;&lt;2）の論理和</td>
</tr>
<tr>
<td>バケット数</td>
<td class="number">40</td>
<td class="number">8</td>
<td>バケット配列の要素数</td>
</tr>
<tr>
<td>レコード数</td>
<td class="number">48</td>
<td class="number">8</td>
<td>格納しているレコードの数</td>
</tr>
<tr>
<td>ファイルサイズ</td>
<td class="number">56</td>
<td class="number">8</td>
<td>データベースファイルのサイズ</td>
</tr>
<tr>
<td>先頭レコード</td>
<td class="number">64</td>
<td class="number">8</td>
<td>最初のレコードのオフセット</td>
</tr>
<tr>
<td>不透明領域</td>
<td class="number">128</td>
<td class="number">128</td>
<td>ユーザが自由に使える領域</td>
</tr>
</table>

<p>バケット部はヘッダ部の直後にバケット配列の要素数に応じた大きさでとられ、ハッシュチェーンの先頭要素のオフセットが各要素に記録されます。各要素は固定長数値で、そのサイズはノーマルモードでは4バイト、ラージモードでは8バイトです。また、オフセットはアラインメントで割った商として記録されます。</p>

<p>フリーブロックプール部はバケット部の直後にフリーブロックプールの要素数に応じた大きさでとられ、未使用領域のオフセットと長さが各要素に記録されます。オフセットはアラインメントで割った商に変換した上で、直前の要素の値との差分として記録されます。オフセットとサイズは可変長数値として扱われます。</p>

<p>レコード部はバケット部の直後からファイルの末尾までを占め、各レコードの以下の情報を持つ要素が記録されます。各レコードの領域は常にアラインメントされた位置から始まります。</p>

<table summary="record format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">1</td>
<td>データの識別と整合性確認に用いる。0xC8固定</td>
</tr>
<tr>
<td>ハッシュ値</td>
<td class="number">1</td>
<td class="number">1</td>
<td>チェーンの進路決定に用いるハッシュ値</td>
</tr>
<tr>
<td>左チェーン</td>
<td class="number">2</td>
<td class="number">4</td>
<td>左チェーン接続先のオフセットのアラインメント商</td>
</tr>
<tr>
<td>右チェーン</td>
<td class="number">6</td>
<td class="number">4</td>
<td>右チェーン接続先のオフセットのアラインメント商</td>
</tr>
<tr>
<td>パディングサイズ</td>
<td class="number">10</td>
<td class="number">2</td>
<td>パディングのサイズ</td>
</tr>
<tr>
<td>キーサイズ</td>
<td class="number">12</td>
<td class="number">可変</td>
<td>キーのサイズ</td>
</tr>
<tr>
<td>値サイズ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のサイズ</td>
</tr>
<tr>
<td>キー</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのデータ</td>
</tr>
<tr>
<td>値</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のデータ</td>
</tr>
<tr>
<td>パディング</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>パディング</td>
</tr>
</table>

<p>ただし、フリーブロックとなった領域には、各レコードの以下の情報を持つ要素が記録されます。</p>

<table summary="free block format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>マジックナンバ</td>
<td class="number">0</td>
<td class="number">1</td>
<td>データの識別と整合性確認に用いる。0xB0固定</td>
</tr>
<tr>
<td>ブロックサイズ</td>
<td class="number">1</td>
<td class="number">4</td>
<td>ブロックのサイズ</td>
</tr>
</table>

<h3>B+木データベースのファイルフォーマット</h3>

<p>B+木データベースが扱う全てのデータはハッシュデータベースに記録されます。記録されるデータは、メタデータと論理ページに分類されます。論理ページはリーフノードと非リーフノードに分類されます。固定長数値と可変長数値の形式はハッシューデータベースと同じです。</p>

<p>メタデータはハッシュデータベースのヘッダにおける不透明領域にとられ、以下の情報が記録されます。</p>

<table summary="database header format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>

<tr>
<td>比較関数フラグ</td>
<td class="number">0</td>
<td class="number">1</td>
<td>比較関数がtcbdbcmplexical（デフォルト）なら0x0、tcbdbcmpdecimalなら0x1、tcbdbcmpint32なら0x2、tcbdbcmpint64なら0x3、それ以外なら0xff</td>
</tr>
<tr>
<td>予約領域</td>
<td class="number">1</td>
<td class="number">7</td>
<td>現状では利用していない。</td>
</tr>
<tr>
<td>リーフ内レコード数</td>
<td class="number">8</td>
<td class="number">4</td>
<td>個々のリーフノードに入れるレコードの最大数</td>
</tr>
<tr>
<td>非リーフ内インデックス数</td>
<td class="number">12</td>
<td class="number">4</td>
<td>個々の非リーフノードに入れるインデックスの最大数</td>
</tr>
<tr>
<td>ルートノードID</td>
<td class="number">16</td>
<td class="number">8</td>
<td>B+木のルートノードのページID</td>
</tr>
<tr>
<td>先頭リーフID</td>
<td class="number">24</td>
<td class="number">8</td>
<td>先頭のリーフノードのID</td>
</tr>
<tr>
<td>末尾リーフID</td>
<td class="number">32</td>
<td class="number">8</td>
<td>末尾のリーフノードのID</td>
</tr>
<tr>
<td>リーフ数</td>
<td class="number">40</td>
<td class="number">8</td>
<td>リーフノードの数</td>
</tr>
<tr>
<td>非リーフ数</td>
<td class="number">48</td>
<td class="number">8</td>
<td>非リーフノードの数</td>
</tr>
<tr>
<td>レコード数</td>
<td class="number">56</td>
<td class="number">8</td>
<td>格納しているレコードの数</td>
</tr>
</table>

<p>リーフノードはレコードのリストを保持し、非リーフノードはページを参照する疎インデックスを保持します。レコードはユーザデータの論理的な単位です。キーが重複する論理レコードは物理的には単一のレコードにまとめられます。物理レコードは以下の形式で直列化されます。</p>

<table summary="record format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>キーサイズ</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>キーのサイズ</td>
</tr>
<tr>
<td>値サイズ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>最初の値のサイズ</td>
</tr>
<tr>
<td>重複数</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーが重複した値の数</td>
</tr>
<tr>
<td>キー</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのデータ</td>
</tr>
<tr>
<td>値</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>最初の値のデータ</td>
</tr>
<tr>
<td>重複レコード</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>値のサイズと値のデータのリスト</td>
</tr>
</table>

<p>リーフノードはレコードの集合を格納するための物理的な単位です。リーフノードは1からインクリメントして振られるID番号で識別されます。リーフノードはID番号を16進数の文字列として表現したデータをキーとし、以下の値を持つレコードとしてハッシュデータベースに格納されます。レコードは常にキーの昇順に整列した状態で保持されます。</p>

<table summary="leaf node format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>前リーフ</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>直前のリーフノードのID</td>
</tr>
<tr>
<td>後リーフ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>直後のリーフノードのID</td>
</tr>
<tr>
<td>レコードリスト</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>ページのレコードを直列化して連結したデータ</td>
</tr>
</table>

<p>インデックスはページを探索するためのポインタの論理的な単位です。インデックスは以下の形式で直列化されます。</p>

<table summary="index format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>ページID</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>参照先のページのID</td>
</tr>
<tr>
<td>キーサイズ</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのサイズ</td>
</tr>
<tr>
<td>キー</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>キーのデータ</td>
</tr>
</table>

<p>非リーフノードはインデックスの集合を格納するための物理的な単位です。非リーフノードは281474976710657からインクリメントして振られるID番号で識別されます。非リーフノードはID番号から281474976710657を引いた値を16進数の文字列とにした上で「#」を接頭させた文字列をキーとし、以下の値を持つレコードとしてハッシュデータベースに格納されます。インデックスは常に昇順に整列した状態で保持されます。</p>

<table summary="non-leaf format">
<tr>
<td class="label">名前</td>
<td class="label">オフセット</td>
<td class="label">データ長</td>
<td class="label">機能</td>
</tr>
<tr>
<td>継承ID</td>
<td class="number">0</td>
<td class="number">可変</td>
<td>最初の子ノードのID</td>
</tr>
<tr>
<td>インデックスリスト</td>
<td class="number">可変</td>
<td class="number">可変</td>
<td>ページ内のインデックスを直列化して連結したデータ</td>
</tr>
</table>

<h3>注記</h3>

<p>データベースファイルはスパースではないので、通常のファイルと同様に複製等の操作を行うことができます。ハッシュデータベースのファイルもB+木データベースのファイルも実行環境のバイトオーダに依存しない形式なので、バイトオーダの異なる環境にデータベースファイルを移設してもそのままで利用できます。</p>

<p>なるべくなら、ハッシュデータベースのファイルをネットワークで配布する際には、MIMEタイプを `<code>application/x-tokyocabinet-hash</code>' にしてください。ファイル名の接尾辞は `<code>.tch</code>' にしてください。B+木データベースのファイルをネットワークで配布する際には、MIMEタイプを `<code>application/x-tokyocabinet-btree</code>' にしてください。ファイル名の接尾辞は `<code>.tcb</code>' にしてください。</p>

<p>データベースファイルのマジックデータを `<code>file</code>' コマンドに識別させたい場合は、`<code>magic</code>' ファイルに以下の行を追記してください。</p>

<pre># Tokyo Cabinet magic data
0       string    ToKyO\ CaBiNeT\n   Tokyo Cabinet
&gt;14     string    x                  \b (%s)
&gt;32     byte      ^1                 \b, Hash
&gt;32     byte      &amp;1                 \b, B+ tree
&gt;33     byte      &amp;1                 \b, [open]
&gt;33     byte      &amp;2                 \b, [fatal]
&gt;34     byte      x                  \b, apow=%d
&gt;35     byte      x                  \b, fpow=%d
&gt;36     byte      &amp;1                 \b, [large]
&gt;36     byte      &amp;2                 \b, [deflate]
&gt;36     byte      &amp;4                 \b, [tcbs]
&gt;40     lelong    x                  \b, bnum=%d
&gt;48     lelong    x                  \b, rnum=%d
&gt;56     lelong    x                  \b, fsiz=%d
</pre>

<hr />

<h2 id="faq">よく聞かれる質問</h2>

<dl>
<dt>Q. : Tokyo CabinetはSQLをサポートしますか？</dt>
<dd>A. : Tokyo CabinetはSQLをサポートしません。Tokyo CabinetはRDBMS（関係データベース管理システム）ではありません。組み込みのRDBMSを求めるなら、SQLiteなどを利用するとよいでしょう。</dd>
<dt>Q. : Berkeley DBとどう違うのですか？</dt>
<dd>A. : 時間効率と空間効率の双方でTokyo Cabinetが優っています。トランザクションの機能と耐障害性についてはBerkeley DBの方が優っています。</dd>
<dt>Q. : アプリケーションの良いサンプルコードはありますか？</dt>
<dd>A. : 各APIのコマンドのソースコードを参考にしてください。`<code>tchmgr.c</code>' と `<code>tcbmgr.c</code>' が最も簡潔でしょう。</dd>
<dt>Q. : データベースが壊れたのですが、どうしてでしょうか？。</dt>
<dd>A. : 大抵の場合、あなたのアプリケーションがきちんとデータベースを閉じていないのが原因です。デーモンプロセスであろうが、CGIスクリプトであろうが、アプリケーションが終了する際には必ずデータベースを閉じなければなりません。なお、CGIのプロセスはSIGPIPEやSIGTERMによって殺されることがあることにも留意しましょう。</dd>
<dt>Q. : データベースを壊れにくくするにはどうすればよいですか？</dt>
<dd>A. : できるならハッシュデータベースを使ってください。ハッシュデータベースはB+木データベースに比べてクラッシュに強いです。それが無理なら、B+木データベースAPIのトランザクション機能を使ってください。これもアプリケーションのクラッシュに対してある程度の耐性があります。</dd>
<dt>Q. : 壊れたデータベースを修復するにはどうすればよいですか？</dt>
<dd>A. : データベースファイルをロックなしオプション（<code>HDBONOLCK</code>か<code>BDBONOLCK</code>）をつけて開いて、最適化機能（<code>tchdboptimize</code>か<code>tcbdboptimize</code>）を実行してください。コマンドラインで修復処理を行いたい場合、「<code>tchmgr optimize -nl casket</code>」もしくは「<code>tcbmgr optimize -nl casket</code>」を実行してください。</dd>
<dt>Q. : 性能を引き出すシステムの設定はどんなものがありますか？</dt>
<dd>A. : できれば、データベースのサイズと同等以上のRAMをマシンに搭載してください。そして、I/Oバッファのサイズを大きくし、ダーティバッファをフラッシュする頻度が少なくするように設定してください。ファイルシステムの選択も重要です。Linux上では、通常はEXT2が最高速ですが、EXT3のwritebackモードの方が速いこともあります。ReiserFSもかなり高速です。EXT3のその他のモードはかなり遅いです。他のファイルシステムに関しては各自で実験してみてください。</dd>
<dt>Q. : 2GBを越えるサイズのファイルを扱おうとするとエラーになるのですが、どうしてですか？</dt>
<dd>A. : 32ビットのファイルシステムでは、LFSなどの明示的な指定をしないと2GBを越えるサイズのファイルを作ることができません。32ビットOS上でXFSやFeiserFSなどの64ビットファイルシステムを利用する場合は2GBを越えるサイズのファイルを扱うことができますが、その際にはTokyo Cabinetを `<code>--enable-off64</code>' をつけた設定でビルドしておく必要があります。純粋な64ビット環境で利用する場合は特別な設定は必要ありません。なお、ulimitやquotaでファイルサイズの制限がかかっていないことも確認しておいてください。</dd>
<dt>Q. : なぜファイルの読み書き全てをmmapを使ってやらないのですか？</dt>
<dd>A. : 遅いからです。mmapはページ（だいたい4096バイト）単位での読み書きをする場合は効率的ですが、それよりも小さい単位で読み書きする際には効率が悪いのです。</dd>
<dt>Q. : QDBMはもうメンテナンスしないのですか？</dt>
<dd>A. : メンテナンスは続けます。積極的な機能追加の予定はありませんが、もしバグが見つかれば対処します。</dd>
<dt>Q. : Windowsで利用できませんか？</dt>
<dd>A. : 残念ながらできません。今のところ対応予定もありません。</dd>
<dt>Q. : 「Tokyo Cabinet」の名前の由来はなんですか？</dt>
<dd>A. : 作者が住んでいる街なので「tokyo」で、モノをしまうから「cabinet」です。略して「TC」と呼ぶのもよい考えです。「東京キャビネット」とか「とうきょうきゃびねっと」とかいう表記でも構いません。東京ディズニーランドや東京ラブストーリーや東京パフォーマンスドールとは一切関係ありません。識別子以外で「TokyoCabinet」とつなげて表記するのは推奨しません。</dd>
<dt>Q. : あなたは千葉県とどういう関係なのですか？</dt>
<dd>A. : 特に関係はありません。出身地は埼玉県です。落花生は好きです。</dd>
</dl>

<hr />

<h2 id="license">ライセンス</h2>

<p>Tokyo Cabinetはフリーソフトウェアです。あなたは、Free Software Foundationが公表したGNU Lesser General Public Licenseのバージョン2.1あるいはそれ以降の各バージョンの中からいずれかを選択し、そのバージョンが定める条項に従ってTokyo Cabinetを再頒布または変更することができます。</p>

<p>Tokyo Cabinetは有用であると思われますが、頒布にあたっては、市場性及び特定目的適合性についての暗黙の保証を含めて、いかなる保証も行ないません。詳細についてはGNU Lesser General Public Licenseを読んでください。</p>

<p>あなたは、Tokyo Cabinetと一緒にGNU Lesser General Public Licenseの写しを受け取っているはずです（`<code>COPYING</code>' ファイルを参照してください）。そうでない場合は、Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA へ連絡してください。</p>

<p>Tokyo Cabinetは平林幹雄が作成しました。作者と連絡をとるには、`<code>mikio@users.sourceforge.net</code>' 宛に電子メールを送ってください。</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
